### 构造函数、拷贝构造函数、析构函数、operator=拷贝函数
- 编译器默认给类添加了无参的构造函数和析构函数、以及拷贝构造函数、operator=拷贝函数（运算符=的重载，内部实现就是拷贝构造函数）
- 如果自定义了有参构造函数那么编译器不会提供默认的无参构造函数，但是拷贝构造函数还是会提供，除非自定义的是拷贝构造函数
- 如果类中有其他的类成员属性，那么在构造对象时先一个个的调用内部成员类构造函数创建成员对象，再构造整个对象，
- 而析构函数的调用与构造函数的相反，先调用整个对象的析构函数再一个个的调用内部成员类析构函数释放对象

 

### explicit修饰的构造函数不允许使用隐式调用 例如不允许写 Person p='e';
### 简单的构造函数成员赋值   Person(int m_a, char m_b) { a = m_a; b = m_b;}  可以简写为  Person(int m_a,char m_b): a(m_a),b(m_b) { }

~~~c++
# define _CRT_SECURE_NO_WARNINGS
#include <iostream> // 标准输入输出
using namespace std; 

class Person {
public:
	int a;
	char b;
public: 
	// 构造函数在对象创建时自动调用
	// 构造函数名称与类名一致，没有返回值，参数自定义类型和数量
	// 构造函数可以重载
	Person() {
		cout << "无参构造函数被调用了" << endl;
	}

	Person(int pa) {
		a = pa;
		cout << "有参构造函数被调用了" << endl;
	}

	Person(const Person &p) {
		a = p.a;
		cout << "拷贝构造函数被调用了" << endl;
	}
	
	// 构造函数初始化成员属性赋值正常写法
    //Person(int m_a, char m_b)
	//{
	//	a = m_a;
	//	b = m_b;
	//}

    // 构造函数初始化成员属性赋值简写
	Person(int m_a,char m_b): a(m_a),b(m_b)
	{
	}
	
	// explicit修饰的构造函数不允许使用隐式调用 例如不允许写 Person p='e';
	explicit Person(char pb) {
		b = pb;
	}
	
	// 析构函数在对象被回收时自动调用
	// 析构函数名称是  类名前面添加 ~ 符号，没有返回值和参数
	// 构造函数不能重载
	~Person() {
		cout << "析构函数被调用了" << endl;
	}
};

int main() {
	// 方式一：直接 '类名 变量名' 调用无参构造函数
	// 注意无参构造函数调用不能写成 Person p(); 这会被编译器认为是一个函数的声明而不是无参构造函数调用  
	Person p; 
	p.a = 100;
	cout << p.a << endl;


	// 方式二：直接 '类名 变量名(构造参数)' 根据构造参数类型和个数匹配对应的有参构造函数
	// 方式二的其他写法 '类名 变量名=类名(构造参数)' 例如 Person p1 = Person(100);
	// 注意拷贝构造函数创建对象不能直接写 类名(拷贝的对象) 编译器会去除括号认为是变量的定义 例如Person p2=Person(p1);
	// 只能使用 类名 变量名(构造参数) 例如 Person p2(p1);
	Person p1(200);
	cout << p1.a << endl;
	
	
	// 方式三：只有一个构造参数时可以写隐式调用有参构造函数  类名 变量名=构造参数 例如 Person p3=222;
	// explicit修饰的构造函数不允许使用隐式调用 例如不允许写 Person p='e'; 调用上述构造函数
	// 当然隐式调用也不能调用拷贝构造函数，因为编译器会认为那是对象的引用赋值操作
    Person p3=222;
    cout << p3.a << endl;

	// 方式四：匿名对象的创建，对象创建完立刻调用析构函数回收对象
	Person(300);
	return 0;
} 
~~~
---
 