### pod的生命周期分为3个阶段

- 第一阶段：启动pause：初始化网络栈、共享挂载网络卷
- 第二阶段：按照顺序执行initC容器，initC有退出终止逻辑，只有前一个initC容器执行成功退出后才执行后一个initC容器，当所有的initC执行成功退出后才进入pod第三阶段，只要有一个initC容器启动执行失败则立即重新启动整个pod，重新回到第一阶段（initC容器的数量是0到无穷大）
- 第三阶段：同时启动所有的mainC，mainC容器的启动完成的顺序是随机的（mainC容器的数量是1到无穷大）


### initC的使用用途
1. 角色分离
2. 一些mainC容器工具的封装
3. mainC容器的延时启动

### 钩子设置(Pod Hook)
钩子是指在满足条件时执行一下任务

第三阶段中每一个mainC容器都可以在容器启动时和容器关闭时设置钩子

mainC容器启动时的钩子并不保证在容器启动前执行完钩子

mainC容器关闭时的钩子保证在钩子执行完再关闭容器

钩子的类型有两种exec和HTTP，exec是执行一段命令、Http是发送HTTP请求

### 探针设置
探针设置是针对第三阶段mainC容器

探针监测分为两种：就绪探针监测（readinessProde）和存活探针监测（livenessProde）

- 就绪探针监测：监测mainC容器是否启动成功，如果启动成功就给用户访问容器，启动失败则不提供给用户访问容器。就绪探针每隔一段时间就判断容器是否就绪，如果未就绪或者是未知则一段时间后继续进行就绪探针监测，直到成功。如果就绪探测失败，端点控制器将从与Pod匹配的所有service的端点中删除该Pod的IP地址。初始延迟之前的就绪状态默认为Failure，如果容器不提供就绪探针，则默认状态为Success

- 存活探针监测：监测mainC容器是否存活，如果存活或者是未知则不处理，如果死亡则关闭执行重启策略，重启策略有三种，第一种是只要死亡就重启（Always），第二种是只要关闭退出出现异常时重启（OnFailure ），第三种直接不重启（Never），默认是第一种重启策略。存活探针每隔一段时间就通过TCP或者是HTTP和脚本（TcpSocketAction、HttpGetAction、ExecAction）判断容器是否存活，如果存活则一段时间后继续进行存活探针监测，直到失败执行重启策略。TCP的监测是端口有没有响应，有响应就存活，HTTP的监测是响应码打印等于200小于400就存活，脚本的监测是判断脚本的返回码是0就存活。如果容器不提供存活探针，则默认状态为Success

 