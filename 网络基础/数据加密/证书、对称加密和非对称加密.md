### 使用http不添加证书的问题
- 客户端和服务端互相在网络传输的所有内容都是明文的，保证不了传输数据的机密性，会泄漏数据
- 保证不了传输数据的机密性，会被中间人修改传输的数据

### 对称加密
客户端和服务端使用同一把私钥，双方都使用这把私钥对传输的数据进行加密和解密，常见的对称加密有AES、DES等
并且客户端和服务端的每一次会话通信都使用一把新的私钥（统称会话密钥），这样中间人破解会话的难度会进一步加大
对称加密的缺点是使用的私钥在客户端和服务端必须提前在线下协商好，原因是想要安全的数据传输方式就必须双方使用同一把私钥，在一开始客户端和服务端没有私钥的情况下直接传输私钥，无法保证私钥的机密性，会泄漏私钥导致后续使用私钥进行数据通信还是不安全

### 非对称加密
- 首先服务端生成一对公钥和私钥，这对密钥的特点是公钥加密的数据只有私钥可以解密，常见的非对称加密有RSA等
  - 服务端发送公钥给客户端，然后客户端通过公钥加密会话密钥生成一段字符串发送给服务端，服务端收到字符串之后使用私钥解密得到会话密钥
后续可以客户端和服务端通过这段会话密钥（对称加密的密钥）进行一次安全的通信
  - 缺点是最开始服务端发送公钥给客户端时，中间人可以拦截请求获取到服务端公钥，记录下服务端公钥，然后自己生成一对公钥和私钥，将自己生成的公钥发送给客户端，当客户端通过中间人公钥加密会话密钥生成一段字符串发送给服务端时，中间人再次拦截请求使用自己生成的私钥进行解密获取到会话密钥，然后中间人继续记录客户端的会话密钥，并且自己编写一段会话密钥使用之前记录的服务端公钥加密再发送给服务端，最终服务端接收到字符串使用服务端私钥解密得到的是中间人的会话密钥，这样中间人在客户端和服务端神不知鬼不觉的情况下篡改了会话密钥。在这种情况下服务端和客户端的通信都会经过中间人，中间人可以任意的窃取和篡改服务端和客户端之间互相通信的任意内容


### 证书颁发机构，简称CA机构
服务端先将服务端公钥和申请者的网站信息发送给所有人都信任的CA机构
如何让所有人都信任CA机构？CA机构引入了证书透明机制：要求CA机构颁发证书时需要向日志服务器写入相应的日志记录，而所有人都可以查阅日志服务器的日志，从而达到互相监督的目的
数字签名是公钥密码学中的一种技术，用于验证信息的完整性和发送者的身份。简而言之，数字签名是一种确认信息来源和信息完整性的手段，并不能保证数据没有被中间人查看
例如所有人都有公钥，但是只有服务端有私钥的情况下，公钥加密数据只有服务端的私钥解密不会被中间人拦截解开查看数据，而服务端私钥加密的数据返回给客户端时的数据会被中间人使用公钥解开查看数据。
解决方案一：客户端额外生成非对称密钥的客户端公钥然后使用服务端的公钥加密后发送给服务端，由于中间人没有服务端的私钥所以无法查看数据，服务端收到服务端公钥加密的客户端公钥后使用服务端的私钥解密得到客户端的公钥，之后服务端返回的数据都先使用客户端的公钥加密发送给客户端，由于中间人没有客户端的私钥也就没有办法查看返回的数据了，客户端收到服务端的数据后使用客户端的私钥解密就可以获取到数据了，后续重复这个流程通信中间人是没有办法获取到数据的，但是缺点是CA机构私钥、服务端私钥、客户端私钥，只要有一个私钥泄漏都会导致通信出现中间人窃取数据或篡改数据
解决方案二：客户端直接生成会话密钥（对称密钥），然后使用服务端的公钥加密，由于中间人没有服务端的私钥所以无法查看数据，服务端收到服务端公钥加密的对称密钥后使用服务端的私钥解密得到对称密钥，双方可以通过这个对称密钥进行加密和解密传输数据，由于对称密钥的泄漏导致中间人可以解开之前拦截全部的加密数据包，所以这个对称密钥会在每次重新建立连接都会重新生成


# 完整的证书颁发和服务端与客户端通信
- 服务端生成一对公钥和私钥，当然有些时候这个步骤是CA机构会帮你完成
- 服务端将服务端公钥和申请者的网站信息发送给所有人都信任的CA机构
- CA机构会根据服务端公钥和申请者的网站信息进行哈希运算（例如sha256RSA）得到一串字符串
- CA机构会自己生成一对公钥和私钥，然后CA机构会使用私钥加密上述哈希运算结果的字符串，得到数字签名
- CA机构会根据数字签名和、申请者的公钥、申请者的网站信息、颁发者CA机构的信息(包含哈希运算的算法和私钥加密签名算法)生成数字证书
- 服务端提前从CA机构获取生成的数字证书
- 服务端和客户端通信开始，服务端首先发送数字证书给客户端，客户端会进行验证数字证书
- 客户端根据服务端数字证书中的明文信息使用相同哈希运算生成字符串H1
- 通过颁发数字证书CA机构的获取对应的CA证书，该CA证书中对应的公钥用于解密服务端数字证书中的数字签名得到H2
- 客户端比对上述H1和H2，如果不一致就说明服务端发来的数字证书被中间人篡改了
- 中间人拦截请求之后，由于没有CA机构的私钥，所以无法确保修改数字签名或数字证书中的其他明文信息在进行计算出H1和H2之后保持一致
- 浏览器检查数字证书中的主题背景中CN（公网域名）和正在访问的网站域名是否一致，当然也有些情况下域名是不一致的，这时浏览器会继续线程数字证书中扩展程序下的证书主题备用名称中是否包含当前正在访问的网站域名，证明域名和证书是正确绑定的
- 浏览器也会检查证书的有效期
- 并且浏览器继续检查证书颁发的CA机构是否是合法的，通过内置的一些根CA证书进行检查下面的后代CA证书
- 然后客户端从数字证书中取出服务端公钥，客户端通过服务端公钥加密会话密钥生成一段字符串发送给服务端，服务端收到字符串之后使用私钥解密得到会话密钥
后续可以客户端和服务端通过这段会话密钥（对称加密的密钥）进行一次安全的通信

### CA机构的CA证书验证
- CA机构的公钥放在CA机构对应的CA证书之中，该CA证书是通过上层CA机构的私钥给颁发的
- 至于上层CA机构的公钥证书是由更加上一层的CA机构颁发的，这样形成了CA机构的证书颁发链路，最上层的CA机构是自己给自己颁发证书，该证书也叫根CA证书
- CA机构的CA证书验证是由上一层CA机构的CA证书进行验证，最上层的CA机构是由根CA证书自己验证自己
- 操作系统或者浏览器中内置了根CA的证书以及一些二级证书，默认会使用这些证书去验证给浏览网站颁发数字证书的CA机构它们的CA证书

### 为什么有中间CA机构？
- 原因是中间CA机构的私钥泄漏只会影响该CA机构和该CA机构之下后代CA机构，而不会影响兄弟CA和祖辈CA机构的正常运作

### 网站服务器的私钥泄漏，吊销CA机构颁发的证书
- 向CA机构申请证书的吊销并且重写生成证书
- 吊销完成后在浏览器重新访问网站在新的证书中扩展程序的CRL分发点下有证书的吊销列表，浏览器会检查吊销列表，如果还在使用这些吊销证书提示不安全，当然有些浏览器不会去检查这个吊销列表会造成安全隐患
- 当然有些时候浏览器也会去主动的在证书中扩展程序的授权中心信息访问权限下通过OCSP响应程序去向CA证书颁发者询问证书是否被吊销，但是注意这有隐私泄漏的问题

### 为什么需要通常都是使用非对称加密来传输对称加密密钥后使用对称加密进行通信？而不是直接使用非对称加密进行通信？
- 非对称加密后的密文比加密后的密文更加长，所以数据量要大，传输的效率低
- 非对称加密相比于对称加密在加密和解密都更加的耗费计算资源，进而影响通信效率
- 直接使用非对称加密中间人可以拦截大量的数据包等待机会，一旦CA机构颁发证书的私钥泄漏，中间人就可以通过私钥解密之前拦截的全部数据包，而使用对称加密则只会泄漏当前的会话密钥，最多只会泄漏当前的会话数据包，而不是之前的全部数据包

### 对称加密之DH加密
可以在不安全的网络中，通过交换一些公开的信息协商出共享密钥，使用此共享密钥建立安全通讯。它实际上并没有直接交换密钥，而是通过数学计算，得出共享密钥。
DH算法分类标准有两类：第一种是基于密钥；第二类基于计算方式。
静态DH是指：通信双方有一方的私有密钥是固定的，另一方临时生成，一般是服务器端固定。但是这样随着时间的验证，很容易被破解，而一旦被破解，之前所有的通讯数据都很容易被解密，不具备前向安全的特性。目前静态DH基本不用。
既然静态DH算法中，一方固定一方临时生成的方式不安全，那么我们就双方都不固定。通讯双方的私有密钥都采用临时生成的方式，这中DH算法称之为DHE算法（E是指Ephemeral, 临时的）。
模指数MODPDH算法和椭圆曲线ECDH算法
模指数MODPDH算法如下
有限域的离散对数问题的复杂度正是支撑DH密钥交换算法的基础。理论基础是：有限域离散对数的困难性。已知g,a,p求解A非常简单；而根据g,p,A在[1,p]范围内求解a却非常的困难，尤其当p特别大的时候，常见的DH组的p比特位有768,1024,2048，…, 8192等，但是注意目前来说2048位以下的p已经不安全了
- 首先客户端生成随机数a、a1，服务端生成随机数b、b1
- 客户端生成两个随机数的g和p，通过对g的a次方对p求余运算得出A $$A=g^amodp$$
- 客户端传递A、g、p、a1给服务端，服务端使用相同的运算：对g的b次方对p求余运算得出B$$B=g^bmodp$$，然后将B、还有之前的b1返回发送给客户端
- 然后客户端和服务端都使用相同的运算得出相同的K，这个K就是Pre-Master预主密钥
- 客户端计算K$$K=B^amodp$$，服务端计算K$$K=A^bmodp$$
- 客户端和服务的都继续通过调用PRF函数，传递K、a1、b1调用生成主密钥
- 预主密钥生成主密钥完成后，预主密钥应当从内存中删除。避免攻击者获取预备主密钥，如果攻击者获取到了预主密钥，加上 ClientHello.random 和 ServerHello.random 传输过程中是不加密的，也容易获取，那么攻击者就可以合成主密钥并进一步导出会话密钥，这样整个加密过程就被完全破解了。
- 通过主密钥生成以下6个密钥  
(1) 客户端MAC密钥  
(2) 服务端MAC密钥   
(3) 客户端对称密钥  
(4) 服务端对称密钥  
(5) 客户端IV密钥   
(6) 服务端IV密钥   
- 这样客户端加密使用客户端对称密钥，服务端使用客户端对称密钥进行解密。同样服务端加密使用服务端对称密钥加密，客户端使用服务端对称密钥解密
- 客户端MAC和服务端MAC密钥用于验证数据，客户端IV密钥和服务端IV密钥用于加密向量初始化，当然这些不是必须的，不同的加密套件不同
- 当然上述模指数MODPDH算法属于静态DH算法，中间人可以重复使用拦截的数据包发送数据，导致客户端重复请求造成DOS攻击并且造成客户端重复付款、重复下单购买物品等破坏行为，解决方法是动态的每次请求都生成不同的对称密钥，且使用一次之后就无法再次使用，例如上述的ECDH算法临时的对称密钥生成

### tls1.2的缺点
- tls1.2直接使用非对称加密密钥的问题：中间人可以拦截大量的数据包等待机会，一旦CA机构颁发证书的私钥泄漏，中间人就可以通过私钥解密之前拦截的全部数据包
- tls1.2建立安全的连接需要多次请求，例如需要服务端和客户端先协商加密套件，后续再根据不同的加密套件进行生成或者传输对称加密密钥，过程过于繁琐吃计算机网络资源

### tls1.3详情
参考：https://blog.csdn.net/SkyChaserYu/article/details/104716229
1. 客户端发送 ClientHello 消息，该消息主要包括客户端支持的协议版本、会话ID、密码套件、压缩算法、以及扩展消息（密钥共享、预共享密钥、预共享密钥模式）；
2. 服务端回复 ServerHello，包含选定的加密套件；发送证书给客户端；使用证书对应的私钥对握手消息签名，将结果发送给客户端；选用客户端提供的参数生成临时公钥，结合选定的参数计算出用于加密 HTTP 消息的共享密钥；服务端生成的临时公钥通过 KeyShare 消息发送给客户端；
3. 客户端接收到 KeyShare 消息后，使用证书公钥进行签名验证，获取服务器端的临时公钥，生成会话所需要的共享密钥；
4. 双方使用生成的共享密钥对消息加密传输，保证消息安全。







