# Java编译执行
Java的编译执行过程包括源码编译、类加载、解释执行、JIT编译执行、AOT编译这5部分内容。本节先对这5部分内容进行粗略介绍，对编译执行有一个系统性的认识，后面再对其中较复杂的类加载、JIT编译进行详细讲解。

经常听说，Java语言的执行效率没有C/C++语言高，这样的说法是否是事实呢？
## 源码编译
源码编译指的是将.java文件编译成.class文件（字节码）的过程。源码编译由javac编译器来完成。
实际上，源码编译过程跟编译型语言中的编译过程类似，它们都需要经过词法分析、语法分析、语义分析等经典的编译过程。两者的区别在于，Java源码编译的结果为字节码，编译型语言中的编译结果为机器码。除此之外，Java源码编译还做了一些特殊的工作，比如注解处理和解析语法糖。接下来，重点看下注解处理和解语法糖，对于词法分析、语法分析、语义分析，它们属于编译原理中所讲的内容，这里就不再展开深入讲解，可以查看编译原理书籍来了解。
### 注解处理
从JDK6开始，javac编译器开始支持JSR269规范（Pluggable Annotation Processing API）。只需要按照这个规范来开发注解插件（插件包含定义注解、使用注解、注解处理器这三部分内容），javac编译器便会在执行源码编译时调用注解插件执行相应的注解处理器代码。
在开发中经常用到的Lombok插件便是按照JSR269规范开发的注解插件。在编译代码时，javac编译器会调用Lombok插件的注解处理器，注解处理器根据@getter、@setter等注解，为类、成员变量生成getter、setter等方法。Lombok插件中定义的注解大部分都是SOURCE级别的，只存在于源码中。当代码编译成字节码之后，这些注解便没有存在的意义了。毕竟JVM并不关心getter、setter方法来自于程序员亲自编写，还是Lombok注解。
### 解析语法糖
Java作为一种高级语言，从一开始就特别重视开发效率（即易用性），而非一味追求执行效率（即性能）。这跟C/C++语言正好相反，这也是两类语言使用场景的重要区别依据。Java更适合做业务系统开发，C/C++语言更适合偏底层的系统开发。
为了提高开发效率，Java提供了很多语法糖。所谓语法糖，指的是对已经存在的基本语法的二次封装，比如泛型、自动装箱拆箱、for-each遍历、内部类等等都是语法糖。在执行源码编译时，编译器会将语法糖解析为基本语法。字节码并不包含语法糖，JVM也不会感知到语法糖。语法糖仅存在于源码中。
接下来，依次来看下这些语法糖。
对于泛型来说，泛型只存在于源码中。在进行源码编译时，编译器会对泛型进行类型擦除，字节码中并不存在使用两个尖括号指定类型的语法，也就是说，代码中的List<Integer>和List<String>在字节码中都表示为List，里面存储的都是Object类型的数据。泛型中的类型仅仅是编译器做类型检查所用。这也是Java中的泛型被称为伪泛型的原因。

自动装箱和拆箱是为了方便基本类型和包装类互相转换。如下所示。实际上，自动装箱底层依赖Integer类的valueof()方法来实现。自动拆箱底层依赖Integer类的intValue()方法来实现。
~~~java
Integer iobj = 12; 底层实现为：Integer iobj = Integer.valueof(12);
int i = iobj; 底层实现为：int i = iobj.intValue();
~~~

for-each遍历也叫做增强for循环，底层依赖迭代器来实现。如下代码所示。
~~~java
List<String> arr = Arrays.asList("xiao", "zheng", "ge");

// for-each循环遍历等价于下面的迭代器遍历
for (String s : arr) {
  System.out.println(s);
}

// 迭代器遍历
Iterator<String> itr = arr.iterator();
while (itr.hasNext()) {
  System.out.println(itr.next());
}
~~~

内部类也是一种语法糖。当编译成字节码之后，外部类编译为A.class，内部类编译为A$B.class，匿名内部类编译为A$1.class，它们均为独立的类
~~~java
public class A { // A.class
  public class B {} //内部类->A$B.class

  public void f() {
    Thread t1 = new Thread(new Runnable() { //匿名内部类->A$1.class
      @Override
      public void run() {
        System.out.println("I am in anonymous inner class.");
      }
    });
  }
}
~~~

## 类加载
在Java应用程序执行的过程中，类的字节码是按需加载到内存中的。当类第一次创建对象，或者类的方法被调用时，这个类就会被加载到内存中。类加载的过程又可以细分为验证、准备、解析、初始化等几个步骤，并且，类的加载遵从双亲委派规则，不同的类由不同的classLoader加载器来加载。对于类加载在后面的笔记进行详细介绍。
拿以下代码举例来看下类的字节码格式。
~~~java
public class Demo {
  private String greeting= "hello";

  public String greet(String name) {
    return greeting;
  }
}
~~~

将上述Demo.java用javac编译器编译之后，得到的是二进制格式化的Demo.class文件。为了方便阅读，再利用javap工具对Demo.class进行反编译，得到具体的内容。
发现一个完整的类主要包含魔数、版本号、访问标志、类、父类、接口、常量池、字段表、方法表这几部分内容。
- 魔数是一个固定值，其十六进制表示为0xCAFEBABE，用来标记文件为Java class文件。
- 版本号指的是class文件是采用哪个版本的JDK编译得到的。版本号包含主版本号和次版本号。JDK1.1对应的主版本号是45，JDK每增加一个版本，这里的主版本号就加1，比如，JDK9对应的主版本号为53。
- 访问标志有很多，比如public、final、abstract、interface等等。
- 类、父类、接口表示此类的继承情况。
- 方法表中存储的是各个函数的字节码。
- 字段表中存储的是类的成员变量。
- 常量池中包含的内容比较多，主要分为两类：字面量和符号引用。字面量也叫做字面值，注意是一个值而非变量，比如“hello”、123，由编译器经过语法分析获得，用来给其他变量赋值。而符号引用是编译原理中的概念，包括这个类所涉及到的类、接口、方法、成员变量的名称和编号。在执行代码的过程中，虚拟机根据符号引用替换代码所引用的类、接口、方法、成员变量的编号为真实内存地址。

## 解释执行
对于C/C++这样的编译型语言，代码会事先被编译成机器指令（即可执行文件），直接交由CPU逐条执行即可。而对于Java语言来说，经过源码编译之后的.class文件，被加载到内存之后，仍然为字节码格式，无法被CPU直接执行。JVM虚拟机需要将字节码逐条取出，边解释为机器指令边交由CPU执行。
对于JVM的解释执行过程，举例解释一下，示例代码如下。
~~~java
public class App {
  public static void main(String[] args) {
    Demo demo = new Demo();
    demo.greet("哈哈");
  }
}
~~~

虚拟机在执行上述代码时，先从main()函数开始执行。当执行到Demo类对象的创建语句时，虚拟机发现内存中没有Demo类的字节码信息，于是，就通过类加载器在classpath对应的路径下查找Demo.class文件，并将其加载到内存中。之后，虚拟机根据Demo类的字节码在堆中创建demo对象。当虚拟机执行demo.greet("哈哈")方法时，虚拟机根据demo对象中的类指针，找到内存中的Demo类，然后在类的方法去中查找greet()函数对应的字节码，最后逐句解释执行。

## JIT编译
解释执行需要在执行的过程中，将字节码解释为机器码，再行交由CPU执行。边解释边执行显然会影响到程序的执行效率，这也是在Java语言发明之初，被认为执行效率没有编译型语言（比如C/C++）高的原因。随着Java语言的发展，为了解决解释执行效率低的问题，Java引入了JIT（Just-in-Time）编译（也叫做即时编译或者运行时编译）。
对于频繁执行的热点代码，比如多次调用的方法或者反复执行多次的循环，JIT编译器在代码的运行过程中，将其编译为机器指令并存储下来。当下次执行这些热点代码时，虚拟机直接将对应的机器指令交由CPU执行即可，不需要边解释边执行，执行效率匹敌编译型语言。
除此之外，JIT编译器还可以在运行期收集代码的运行情况，在进行编译时做针对性的优化，生成更加高效的机器指令，这种编译优化被称为动态编译优化。而C/C++编译型语言的编译优化只发生在运行前的编译时期，无法利用运行信息做优化，这种编译优化被称为静态编译优化。这也是Java语言在性能上有可能超越C/C++编译型语言的地方。
在默认情况下，虚拟机运行于混合模式，即解释执行和JIT编译执行共存，通过java -version 查看显示mixed mode
可以使用-Xint JVM参数强制虚拟机运行于解释模式，即仅支持解释执行，通过java -Xint -version 查看显示interpreted mode
也可以使用-Xcomp强制虚拟机运行于编译模式，即仅支持JIT编译执行，通过java -Xcomp -version 查看显示compiled mode

## AOT编译
实际上，跟JIT编译相对应的编译方法称作AOT编译（Ahead Of Time Compile），也叫做提前编译或者运行前编译。C/C++等编译型语言中的编译便是AOT编译，即在运行前将代码编译成机器码。实际上，除了支持JIT编译之外，Java也支持AOT编译，只是相对不常见而已，并且是JDK9进行引进的
不过，Java AOT编译跟C/C++等编译型语言中的编译有些许不同。对于C/C++等编译型语言，代码的可移植性完全由程序员来负责，很难做到“一次编写，到处运行”。尽管Java AOT编译不支持“一次编译，到处运行”，但仍然需要支持“一次编写，到处运行”，代码的可移植性完全由AOT编译器来负责。针对不同的操作系统，使用不同的AOT编译器，生成不同的机器指令。

### 既然AOT编译既可以在运行前将代码编译成机器指令，同时又可以做到“一次编写，到处运行”，那么，Java为什么还偏向于使用JIT编译呢？
一般来说，编译包含两部分工作，一部分工作是基础编译，即将代码编译成字节码、机器指令等，另一部分工作是编译优化。AOT编译中进行的编译优化为静态编译优化，JIT编译中进行的编译优化为动态编译优化。
相比静态编译优化，动态编译优化有很多优势，它可以基于运行时的统计信息，进行一些比较激进的优化，比如根据运行时的统计信息，直接移除执行概率比较小的代码分支。在实际的运行中，如果万一需要执行被移除的代码分支，那么，虚拟机会退回到使用原始的字节码来解释执行。只要退回到解释执行的概率足够低，这种激进优化就是值得的，带来的性能提升就是非常可观的。这就是Java偏向于使用JIT编译而非AOT编译的原因。
除此之外，JVM不仅仅支持Java编程语言，只要是能够编译成字节码的编程语言，比如Clojure、Groovy、JRuby、Scala，都可以运行在JVM之上。也就是说，JVM并不关心字节码来自于哪种编程语言，只要字节码符合JVM规范即可被JVM执行。这也是Java一直偏向于使用JIT编译的原因。
当然，JIT编译相对于AOT编译有一定的优势，并不代表使用JIT编译的Java语言的性能就比使用AOT编译的C++语言的性能好。毕竟，这种编译优化在实际的应用过程中所表现出来的优势并不是特别明显。而且，编程语言之间的性能，除了受编译优化的影响之外，还受其他很多因素的影响，比如内存布局、内存访问方式、内存管理等。



