## JVM内存模型中有几个分区？都是做什么用的？
JVM将内存划分为不同的分区，其中包括方法区、程序计数器、堆、虚拟机栈、本地方法栈。

### 方法区
类字节码加载到内存中的具体存储位置就是方法区，除此之外，方法区中还会存储JIT编译得到的机器码，以及专门服务于字符串的字符串常量池。具体主要包含以下这几部分内容。
- 类信息：类的全限定名、访问标志以及父类、接口列表等相关信息
- 方法信息：方法的字节码、局部变量表、异常表、参数信息等
- 静态变量：静态变量隶属于类，因此存储在方法区中而非堆上
- 运行时常量池：存储字面量和符号引用。每一个类会对应一个运行时常量池
- 字符串常量池：此分区专门服务于字符串，避免String对象的重复创建，减少内存开销。跟运行时常量池不同，字符串常量池是类之间共享的
- JIT编译代码缓存：此分区存储的是JIT编译之后的机器码

这里特别说明一下字符串常量池。很多人误以为字符串字面量（比如“abc”）存储在字符串常量池中，实际上并不是。字符串常量池中存储的是String对象。当通过String s = "abc"来创建对象时，编译器会将运行时常量池中的字面量“abc”，拷贝一份存储在字符串常量池中的String对象的char value[]成员变量中。

方法区是JVM规范中的抽象分区，当落实到具体的JVM实现时，不同的JVM对方法区有不同的实现方式。拿常用的HotSpot JVM举例说明。在Java7以前的版本中，方法区在HotSpot JVM中实现为永久代（Permanent Generation）。在Java7中，方法区中的字符串常量池和静态变量被从永久代中移除，并放入到堆中。在Java7以后的版本中，永久代被元空间取代（MetaSpace）。在早期Java版本中，类被加载到JVM中之后便不再被卸载，因此，加载类的分区被命名为永久代。但是，随着更多高级功能的加入，比如类的运行时动态加载，在运行的过程，虚拟机可以随意加载、卸载类，因此，从名称上来看，元空间相较于永久代更加适合。除此之外，元空间和永久代的另一个区别在于，永久代的空间大小是固定的，而元空间的大小可以根据加载类的增加而动态增大，这也是为了适应类的运行时动态加载所做的调整。

### 程序计数器
CPU在执行指令的过程中使用程序计数寄存器（Program Counter Register，简称为PC寄存器）存储下一条将要执行的指令的地址。实际上，虚拟机就相当于一个抽象的计算机，也有自己的指令集，那就是字节码集。虚拟机在对字节码进行解释执行的过程中，也需要有这样一个存储单元，存储下一条将要执行的字节码的地址。虚拟机将这个存储单元称为程序计数器。
程序计数器跟PC寄存器的不同之处在于，PC寄存器是线程共享的，PC寄存器的值会随着线程的切换而进行保存和恢复。而程序计数器是线程私有的，虚拟机为每个线程分配一个独立的程序计数器，记录每个线程执行到哪一行字节码。之所以有这样的区别，是因为PC寄存器的比较昂贵，数量有限，而程序计数器位于内存中，没那么昂贵。线程独享程序寄存器能减少线程上下文切换的信息量，有利于提高线程切换的速度。

### 堆
堆用来存储Java对象。在Java中，对象的回收是由虚拟机中的垃圾回收器自动完成的。堆是垃圾回收器的主要工作分区。为了配合垃圾回收算法，堆又被划分为更加细粒度的分区，比如堆被划分为年轻代（Young Generation）和老年代（Old Generation），年轻代又被划分为Eden区和Survivor区，而Survivor区又被划分为From Survivor区和To Survivor区。对于堆，会在后面结合分代垃圾回收算法进行更加详细的讲解。

### 虚拟机栈
栈用来存储函数调用的局部变量、参数、返回地址等信息，因此，栈也被叫做函数调用栈。栈为线程私有的，每个线程都会有一个栈，因此，栈也被叫做线程栈。Java也不例外，把Java中的栈叫做虚拟机栈。

### 本地方法栈
Java提供了很多采用C/C++语言实现的native方法。很多Java函数最终是通过调用native方法来实现的。在JVM规范中，Java将服务于Java方法调用的栈跟服务于native方法调用的栈做了区分。服务于Java方法调用的栈被称为虚拟机栈，而服务于native方法调用的栈被称为本地方法栈。实际上，这两个栈的功能基本是相同的，在具体的虚拟机实现中，这两栈有可能会被合并为一个栈，同时存储Java方法调用的栈帧和native方法调用的栈帧。实际上，HotSpot JVM就是这么做的。
在不同平台下，JVM的默认线程栈大小有些许差别。在64位Linux操作系统下，HotSpot JVM的默认线程栈大小为1MB，当然，可以通过JVM参数-Xss来自定义线程栈的大小。JVM可创建的线程个数由进程可用内存大小（一般就是计算机可用内存）除以线程栈大小决定。可以通过减小线程栈大小来支持创建更多的线程。当然，也可以通过增大线程栈大小来避免函数调用过深导致的栈溢出（即栈内存不够用导致JVM抛出StackOverflowError异常）。

### final类型变量存储在哪里呢？
静态final变量在方法区，实例final在堆作为对象一部分，局部final变量在虚拟机栈



