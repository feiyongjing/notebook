# JVM垃圾回收器
在JVM中，把无用对象的内存释放过程叫做垃圾回收。垃圾回收是JVM的核心功能

# 虚拟机是如何判断一个对象是否可以被回收的？
在C++语言中，当使用完一个对象之后，需要显式地调用delete语句，将这个对象所占用的内存释放，否则就会导致无用对象一直占用内存而产生内存泄露。而在Java语言中，无用对象由JVM负责自动回收，无须由程序员去显式释放，这样既提高了开发效率，又避免了在编程中因忘记释放内存而产生的内存泄露问题。虚拟机在进行垃圾回收时，首先需要判断哪些对象可以被回收。常用的判断方法有引用计数和可达性分析，不过，前者并不常用，只对其做简单介绍。重点介绍可达性分析以及其中涉及到的STW、安全点、安全区等知识点。
~~~c++
void func() {
  Student* stu = new Student();
  ...
  delete stu; //主动释放内存
}
~~~
~~~java
// Java代码
public void func() {
  Student stu = new Student();
  ...
}
~~~

## 引用计数
在Java中，使用引用来表示变量和对象之间的关系，将对象赋值给变量就表示变量引用对象。如果N个变量同时引用某个对象，那么，这个对象的引用计数就是N。如果引用这个对象的某个变量取消与这个对象之间的引用关系，比如变量改为引用其他对象、或者被赋值为null、又或者其生命周期结束，那么，这个对象的引用计数便会减一。当这个对象的引用计数减少为0时，这个对象就可以被虚拟机当做垃圾回收了。
~~~java
public void f() {
    Object a = new Object(); //对象的引用计数为1
    g(a);
    //g(a)退出之后，变量b的生命周期结束，对象的引用计数变为1
} // f()函数结束，变量a的生命周期结束，对象的引用计数变为0，可以被垃圾回收

public void g(Object a) {
    Object b = a; //对象的引用计数为2
    Object c = a; //对象的引用计数为3
    Object d = a; //对象的引用计数为4
    d = new Object(); //变量d重新引用其他对象，对象的引用计数减一，变为3
    c = null; //变量c赋值为null，对象的引用计数减一，变为2
}
~~~
不过，引用计数存在一个严重问题，那就是无法检测循环依赖。如下所示，两个对象互相引用，尽管最后不再有变量引用它们，但它们引用计数仍然不为0，也就无法被回收。这就是大部分虚拟机不使用引用计数作为判定对象是否应该被回收的原因。
~~~java
Wife hanmeimei = new Wife("HanMeiMei"); //Wife对象的引用计数为1
Husband lilei = new Hasband("LiLei"); //Husband对象的引用计数为1
hanmeimei.husband = lilei; //Husband对象的引用计数为2
lilei.wife = hanmeimei; //Wife对象的引用计数为2
hanmeimei = null; //Wife对象的引用计数为1
lilei = null; //Husband对象的引用计数为1
~~~

## 可达性分析
在可达性分析中，使用数据结构中的有向图来表示对象之间的引用关系。有向图中的顶点表示对象。如果对象A中的变量引用了对象B，那么，便在对象A对应的顶点和对象B对应的顶点之间画一条有向边。
有向图中包含一组特殊的顶点，叫做GC Roots。GC Roots为堆外变量所直接引用的堆内对象，包括虚拟机栈和本地方法栈中的局部变量所直接引用的对象以及方法区中静态变量所直接引用的对象等。虚拟机以GC Roots为起点，通过深度优先或广度优先算法来遍历整个有向图。遍历到的对象为可达对象，也叫做存活对象，遍历不到的对象为不可达对象，也叫做死亡对象。死亡对象会被虚拟机当做垃圾回收。
通过可达性分析发现，即便两个对象互相引用，但只要虚拟机从GC Roots出发无法遍历到这两个对象，换句话说，从GC Roots到这两个对象不可达，那么，这两个对象就会被判定为死亡对象，因此，可达性分析可以解决引用计数存在的循环引用问题。

### STW
把运行在虚拟机上的应用程序所启动的线程叫做用户线程，把执行垃圾回收的线程叫做垃圾回收线程。如果虚拟机在执行垃圾回收的同时，用户线程仍然在执行，那么，对象之间的引用关系有可能被用户线程中途更改，这就会导致可达性分析存在误报或者漏报的情况。
误报指的虚拟机将死亡对象误报为存活对象，漏报指的是虚拟机将存活对象漏报，漏报的存活对象会被判定为死亡对象。关于误报和漏报产生的详细原因，在后面讲到三色标记算法时再详细讲解。误报并不会产生问题，它只会导致本该被垃圾回收的对象没有被回收，等待再次垃圾回收即可。漏报会产生严重的问题，它会导致本不该被回收的对象被回收，这显然是无法接受的。
为了解决漏报的问题，比较简单粗暴的解决方法是虚拟机在进行垃圾回收时停止所有用户线程，这样垃圾回收过程就不会被用户线程所打扰。把这个过程形象化地称为Stop The World，简称为STW。STW的时间过长会严重影响应用程序的性能，特别是对响应时间比较敏感的应用程序来说，这种影响尤为明显。因此，尽量减少STW的时间是每个垃圾回收器努力的重点。关于如何减少STW的时间，在后续讲解CMS、G1等垃圾回收器时再详细讲解。

### 安全点
前面提到，可达性分析遍历的起点是GC Roots，那么，GC Roots又是如何获得的呢？比较简单的方法是，虚拟机遍历栈中的局部变量和方法区中的静态变量，然后从中找出引用类型变量，最后再将引用类型变量所引用的对象放入GC Roots中。
每当进行垃圾回收时，虚拟机都要遍历栈和方法区来查找GC Roots，这样做效率非常低。因此，虚拟机使用OopMap来存储当前的GC Roots并实时动态更新。具体的做法是：虚拟机先遍历查找一次GC Roots并初始化OopMap，然后，在代码的执行过程中，如果有变量更新所引用的对象，那么，虚拟机就同步更新OopMap。当虚拟机需要进行垃圾回收时，OopMap中存储的便是当前的GC Roots。
对于解释执行来说，上述OopMap的更新过程没有任何问题。虚拟机每执行一行字节码就同步更新一下OopMap。但是，对于JIT编译执行来说，上述OopMap的更新过程却无法实现。这是因为JIT编译之后的机器码直接交由CPU执行，并不经虚拟机之手。虚拟机无法做到边执行指令边分析指令然后再动态更新OopMap。为了解决这个问题，虚拟机需要在将字节码编译为机器码时，静态地分析指令，然后为每一条指令存储此指令执行结束后对应的OopMap，但是，这样做显然非常浪费内存空间。
为了解决内存的浪费问题，虚拟机采用时间换空间的策略，将为每个指令存储一个OopMap改为只为部分指令存储OopMap。这些被选取的部分指令被称为安全点。当虚拟机启动垃圾回收并发起STW请求时，会向用户线程发送暂停的中断请求。用户线程接收到中断请求之后并不能立刻停止运行，而是需要继续运行到安全点之后才能停止运行，这是因为只有安全点处才记录了OopMap，只有所有的线程都运行到安全点之后，虚拟机才能得到完整的GC Roots。

### 安全区
在大部分情况下，用户线程在接收到暂停的中断请求之后，都可以在较短的时间内到达最近的安全点，但是，在少数情况下，如果用户线程处于阻塞状态（比如等待I/O读写就绪），那么，就无法在较短的时间内到达最近的安全点。为了解决这个问题，虚拟机引入了一个新的概念：安全区。安全区指的是不会改变对象引用关系的一段连续的代码区间，比如线程阻塞等待I/O读写就绪期间并不会改变对象的引用关系，因此，对应代码就属于安全区。
当虚拟机执行垃圾回收并发起STW请求时，如果某个线程处于安全区，那么，这个线程并不需要停止执行，而是可以跟垃圾回收线程并行执行。但是，当用户线程离开安全区时，它需要检查虚拟机是否处于STW状态，如果虚拟机处于是STW状态，那么，用户线程需要阻塞等待STW结束，才能继续往下执行，以免用户线程跳出安全区之后，执行非安全代码导致对象引用关系的改变。

# 垃圾回收算法
如何对死亡对象进行回收，也就是垃圾回收算法。垃圾回收算法又分为基础垃圾回收算法和分代垃圾回收算法
分代垃圾回收算法在基础垃圾回收算法之上增加了分代的概念。虚拟机将堆空间分为年轻代和老年代
针对不同的分代单独进行垃圾回收。针对年轻代的垃圾回收叫做YoungGC，针对年轻代、老年代、永久代的垃圾回收叫做FullGC，FullGC要比YoungGC慢很多

## 基础垃圾回收算法
基础垃圾回收算法有三种，它们分别是：标记-清除、标记-整理、标记-复制。从名称上，也可以看出，无论哪种算法，第一步总是先标记，也就是使用可达性分析找出需要被回收的死亡对象。它们的不同点在于第二步（清除、整理或复制）。

### 标记-清除算法
在标记-清除算法中，虚拟机将死亡对象所占用的内存空间释放，并放入到空闲空间列表中。当创建对象时，虚拟机从空闲空间列表中查找大小合适的空闲空间分配给对象。
标记-清除算法存在内存碎片问题，即经过标记-清除之后得到的空闲空间不连续。这就会导致内存分配效率和内存利用率不高。为对象查找大小合适的空闲空间比较耗时，并且内存碎片有可能因为过小和过凌乱而无法被大对象使用。相对于其他基础垃圾回收算法，标记-清除算法的优点是逻辑简单，垃圾回收速度快。后面讲到的CMS垃圾回收器就用到了标记-清除算法，并在此基础上做了改进，即多次垃圾回收之后进行一次碎片整理。

### 标记-整理算法
标记-整理算法也叫做标记-压缩算法，在标记-清除算法的基础之上，标记-整理算法额外增加了“整理”的环节。标记-整理算法先通过可达性分析标记存活对象，然后，顺序遍历内存空间，将存活对象移动到内存的一端，从而解决了内存碎片问题。
如上图所示，空闲空间为一片连续的内存空间。相对于标记-清除算法，标记-整理算法不需要存储空闲空间列表，只需要记录空闲空间的起止地址即可，虚拟机从空闲空间的起始地址依次为对象分配内存空间。相较于标记-清除算法，标记-整理算法的内存分配的效率更高，但垃圾回收速度要更慢。后面讲到的Serial垃圾回收器就用到了此垃圾回收算法。

### 标记-复制算法
标记-复制算法将整个内存分为两块。其中一块内存为对象分配内存空间，称为工作内存，另外一块内存作为复制时备用，称为备用内存。当工作内存使用完之后，标记-复制算法将这块内存中的存活对象，逐一复制到备用内存中，然后，两块内存互换角色。
尽管标记-复制算法没有内存碎片的问题、垃圾回收速度快，但存在内存利用率不高的问题，只有50%，并且，如果对象的存活时间比较长，那么，对象会在两块内存之间来回复制多次，比较浪费时间。

### 对于以上三种基础垃圾回收算法，总结对比如下表所示
            垃圾回收速度   内存碎片     内存利用率    内存分配效率
标记-清除    快            有           低           低
标记-整理    慢            无           高           高
标记-复制    快            无           低           高

## 分代垃圾回收算法
堆中存储的对象供所有线程共享，其作用域范围大，生命周期长。在使用完成之后并不会被立刻回收。因此，堆是虚拟机进行垃圾回收的重点工作分区。不过，除了堆之外，方法区也会涉及垃圾回收，比如，方法区中的一些无用的类或者无用的String常量对象也需要被回收。无用的String常量对象指的是，存储在字符串常量池中的并且没有变量引用的String对象。无用的类指的是要同时满足以下几个条件的类
- 该类的所有对象都已经被回收
- 类的Class对象（比如Class<?> clazz = Integer.class;）没有任何变量在引用
- 加载该类的类加载器已经被卸载

应用程序所创建的对象的生命周期并不相同，有的对象的生命周期比较短，比如方法内的对象，有的对象的生命周期比较长，比如使用Spring框架创建的单例对象。对于生命周期较短的对象，希望以较高的频率执行垃圾回收，尽快释放所占用的内存空间。对于生命周期较长的对象，希望以较低的频率执行垃圾回收，避免无效的垃圾回收。
因此，虚拟机将堆分为年轻代（Young Generation）和老年代（Old Generation）。年轻代存储生命周期比较短的对象，老年代存储生命周期比较长的对象。虚拟机针对不同的分代（年轻代和老年代），使用不同的基础垃圾回收算法（标记-清除、标记-整理、标记-复制）。在基础垃圾回收算法之上增加分代之后的垃圾回收算法，叫做分代垃圾回收算法。
接下来，就来详细讲解一下年轻代和老年代以及对应的基础垃圾回收算法。

### 年轻代和YoungGC
新创建的对象会分配在年轻代，因此，年轻代也叫新生代（New Generation）。根据统计数据发现，在应用程序中，大部分对象都朝生夕死，存活率比较低，因此，年轻代适合使用标记-复制算法进行垃圾回收。在进行垃圾回收时，虚拟机只需要复制少量存活对象，复制耗时少，执行效率高。把年轻代的垃圾回收叫做YoungGC。
前面提到，标记-复制算法会将整个内存平均分为两块，同一时间只有一块内存在使用，内存利用率只有50%。为了提高内存利用率，虚拟机对标记-复制算法进行了优化，将年轻代分为不均等的三个分区：一个Eden区和两个大小相等的Survivor区。

虚拟机将Eden区和其中一个Survivor区作为分配对象所用，也就是工作分区，将另一个Survivor区作为复制备用，也就是备用分区。除此之外，把供分配对象所用的Survivor区叫做From Survivor区，将复制备用的Survivor区叫做To Survivor区。当工作分区（Eden区和From Survivor区）存满之后，虚拟机便执行标记-复制算法，将Eden区和From Survivor区中的存活对象复制到To Survivor区。当一次垃圾回收结束之后，两个Survivor区的角色互换，原来充当From Survivor的，现在充当To Survivor，原来充当To Survivor的，现在充当From Survivor。

一般情况下，Eden区比较大，Survivor区比较小。默认情况下，虚拟机根据每次垃圾回收之后存活对象的比例，动态调整Eden区和Survivor区的大小比例，当然，也可以通过JVM参数-XX:SurvivorRatio设置固定的比例，比如，-XX:SurvivorRatio=8表示Eden区和一个Survivor区的大小比例为8:1，也就是说，Eden区占年轻代大小的80%，From Survivor和To Survivor各占10%。工作内存为Eden区加From Survivor，因此，内存利用率高达90%。尽管To Survivor区比较小，但基于前面讲到的“大部分对象都朝生夕死”这一规律，在大部分情况下，To Survivor区的大小都足够存一次垃圾回收之后的存活对象。

如果万一To Survivor区存不下一次垃圾回收之后的存活对象，那么，该怎么办呢？对于这种情况，虚拟机会借用老年代的部分空间，将存不下的对象存储在老年代中。在这里，老年代相当于起到了一个担保的作用，因此，这种处理机制叫做空间分配担保。当然，这也会导致一定的问题：部分生命周期比较短的对象存储到了老年代，即便这些对象早早已经死亡，依然需要等待很长时间才能被回收。
如果老年代也没有足够的空间用于分配担保，那么，又该怎么办呢？对于这种情况，虚拟机会执行FullGC（待会会讲到），对整个堆进行一次大规模的垃圾回收，以便腾出更多空闲空间。如果虚拟机在执行完FullGC之后，老年代仍然没有足够的空间，那么，虚拟机就只能抛出OOM（Out Of Memory，即内存溢出）异常了。

### 老年代和FullGC
基于空间分配担保机制，新生代存不下的对象会进入老年代，除此之外，大对象和长期存活对象也会进入老年代。
大对象指的是占用大量连续内存空间的对象，比如大的字符串或数组。默认情况下，不管对象有多大，都会在年轻代创建，但是，如果设置了JVM参数-XX:PretenureSizeThreshold，那么，当对象的大小超过这个预设的阈值之后，对象会直接在老年代创建。这样做的目的是避免生命周期比较长的大对象在年轻代中被反复复制。

长期存活的对象指的是经过多次年轻代的垃圾回收后仍然存活的对象。虚拟机在对象的对象头中记录对象的GC年龄，每经过一次GC，GC年龄就增一，当GC年龄超过一定阈值（默认为15，当然，也可以通过-XX:MaxTenuringThreshold来设置这个阈值）之后，对象便会从年轻代移动到老年代。不过，人为设定一个固定值显然不够灵活，于是，虚拟机设计了动态年龄判定机制，结合存活对象的多少来动态地设置最大GC年龄。
动态年龄判定机制的具体的做法是：统计YoungGC后，处于每个GC年龄值的对象占To Survivor区的比例。按照年龄从小到大累加对象所占比例，当累加到年龄为X的对象时，如果累计对象所占比例超过50%（此值可以通过JVM参数-XX:TargetSurvivorRatio来设置），那么，GC年龄>=X的对象都将直接进入老年代，并不会等到GC年龄大于15。
举个例子解释一下。假设根据统计发现，GC年龄=3的对象占To Survivor区大小的20%，GC年龄=6的对象占To Survivor区大小的40%，GC年龄=8的对象占To Survivor区大小的15%。在这个例子中，GC年龄=3的对象和GC年龄=6的对象占To Survivor区的比例为60%，超过50%，因此，GC年龄=6和GC年龄=8的对象会从年轻代移动到老年代。
前面讲到，年轻代使用标记-复制算法进行垃圾回收，原因是年轻代中的存活对象比较少，复制耗时少。而老年代正好相反，老年代中的对象的生命周期比较长，存活对象比较多，复制耗时多，因此，老年代一般采用标记-整理算法或标记-清除算法进行垃圾回收。
前面讲到，把年轻代的垃圾回收叫做YoungGC，相对应的，把老年代的垃圾回收就叫做OldGC，但是，在主流虚拟机的实现中，比如HotSpot JVM，在对老年代进行垃圾回收的同时，虚拟机会一并对年轻代和永久代（或元空间）进行垃圾回收。把这种大规模的垃圾回收叫做FullGC。

### 同为垃圾回收，为什么FullGC要比YoungGC慢很多？
YoungGC只针对年轻代进行垃圾回收，年轻代中的对象的存活率比较低，可达性分析需要遍历的对象和需要进行复制的对象比较少，所以，YoungGC比较快速，因此，YoungGC也被称为MinorGC。而FullGC针对年轻代、老年代、永久代（或元空间）进行垃圾回收，并且老年代和永久代（或元空间）中的对象存活率比较高，可达性分析需要遍历的对象和垃圾回收需要处理的对象比较多，所以，FullGC比较慢，因此，FullGC也被称为MajorGC。

### 可以通过设置JVM参数-XX:MaxTenuringThreshold，来指定对象在年轻代的最大GC次数，不过，参数值不能超过15，这是为什么呢？
- JVM内部实现角度：JVM内部使用有限的位（通常是4位）来表示对象的年龄，因此这个值被限制在了一个特定的范围内，即0到15
- 对象晋升策略角度：如果一个对象在年轻代中存活了超过15次GC，那么它很可能是一个长期存活的对象，应该直接晋升到老年代，而不是继续在年轻代中占用空间

# 垃圾回收器
## 垃圾回收器的性能指标
不同垃圾回收器的性能特点不同，应用场景也不同，一般来讲，从以下几个指标来评价一个垃圾回收器。
- 吞吐量：吞吐量指的是应用程序运行时间占总运行时间的比值。总运行时间等于应用程序运行时间加上垃圾回收时间（简称GC时间）。吞吐量95%表示在总运行时间中，应用程序运行时间占比95%，GC时间占比5%。吞吐量越大，表示浪费在GC上的时间越少。
- 停顿时间：停顿时间指的是垃圾回收导致应用程序完全停止运行的时间，也就是STW时间。
- 资源消耗：资源消耗指的是虚拟机进行垃圾回收所消耗的CPU和内存资源。
在一些资料中，还会将回收延迟和回收频率作为垃圾回收器的评价指标。回收延迟指的是一个对象从死亡到被回收所经历的等待时间，回收频率指的是虚拟机间隔多久进行一次垃圾回收。实际上，这两者跟垃圾回收器本身没有太大关系，而是跟虚拟机的垃圾回收的整体策略（比如什么情况下触发垃圾回收），以及堆和堆中各个分代大小的设置有关。

## 四大类常用的垃圾回收器
为了满足不同的应用场景，虚拟机提供了很多不同的垃圾回收器，按照实现方式（串行还是并行、是否Stop-The-World、针对年轻代还是老年代等）将众多垃圾回收器分为4类：Serial垃圾回收器、Parallel垃圾回收器、CMS垃圾回收器、G1垃圾回收器。在接下来的讲解中，并不会深入的详细讲解各个垃圾回收器的具体实现方式，一来是因为它们比较复杂，二来是因为了解它们对实际项目开发并没有太大帮助。只需要对各个垃圾回收器的性能特点有一定了解，就可以做到根据不同的项目需求选择合适的垃圾回收器。除此之外，永久代也会进行垃圾回收，但是，永久代一般使用跟老年代相同的垃圾回收器进行垃圾回收，因此，在本节的讲解中，并未提及永久代。

### Serial垃圾回收器
Serial垃圾回收器使用单线程进行垃圾回收，并且，在进行垃圾回收时，虚拟机需要暂停应用程序的运行（也就是Stop The World）。Serial垃圾回收器又分为Serial New和Serial Old。Serial New用于年轻代的垃圾回收，基于标记-复制算法来实现。Serial Old用于老年代的垃圾回收，基于标记-整理算法来实现。

### Parallel垃圾回收器
Parallel垃圾回收器使用多线程进行垃圾回收，可以充分利用CPU资源。跟Serial垃圾回收器相同，Parallel垃圾回收器在进行垃圾回收时，也需要暂停应用程序的运行。Parallel垃圾回收器包含Parallel Scavenge（简称为PS）、Parallel New（简称为ParNew）、Parallel Old（简称为ParOld）三个细分的垃圾回收器。其中，Parallel Scavenge和Parallel New用于年轻代的垃圾回收，基于标记-复制算法来实现，Parallel Old用于老年代的垃圾回收，基于标记-整理算法来实现。Parallel Scavenge跟Parallel Old配合使用，Parallel New跟CMS配合使用。

### CMS垃圾回收器
CMS全称为Concurrent Mark Sweep。CMS垃圾回收器采用多线程执行垃圾回收，跟Parallel垃圾回收器所不同的地方是，CMS垃圾回收器在进行垃圾回收时，并不需要完全暂停应用程序，因此，STW时间更短。需要注意的是，CMS不能用于年轻代的垃圾回收。如果选择使用CMS垃圾回收器，那么，年轻代将默认使用Parallel New垃圾回收器。如果设置JVM参数-XX:-UseParNewGC，那么，年轻代将改用Serial New垃圾回收器。
CMS垃圾回收器将整个垃圾回收过程分为4个阶段：初始标记、并发标记、重新标记、并发清理。其中，初始标记和重新标记需要暂停应用程序，并发标记和并发清理可以与应用程序并发执行。对于CMS如何做到并发标记和并发清理的，在下面详细讲解。

CMS垃圾回收器在与应用程序并发执行的过程中会争抢CPU资源，因此，默认情况下，CMS使用的并发线程数等于(CPU内核数+3)/4。除此之外，CMS垃圾回收器在与应用程序并发执行的过程中也会争抢内存资源，因此，虚拟机在老年代没有完全存满之前就要进行垃圾回收，以便为并发执行的应用程序预留内存空间。
那么，到底老年代中已使用内存占比多少时，虚拟机就会进行垃圾回收呢？实际上，触发垃圾回收的内存占比是由虚拟机根据动态计算得到的。当然，也可以通过JVM参数-XX:CMSInitiatingOccupancyFraction来指定一个固定值，比如，设置-XX:CMSInitialOccupancyFraction=80，那么，当已使用内存占老年代的80%时，虚拟机便会触发CMS垃圾回收器的执行。不过，即便设置再合理的比例值，预留空间总会有不够用的时候，那么，此时虚拟机将中止CMS垃圾回收器的执行，转而使用Serial Old垃圾回收器进行本次垃圾回收。把这种情况叫做Concurrent Mode Failure。
除此之外，为了进一步减少STW时间，CMS采用标记-清除算法来实现，相对于标记-整理算法，省去了整理空闲空间的时间。前面讲到，标记-清除算法存在内存碎片问题，影响对象的内存分配效率。为了解决这个问题，CMS垃圾回收器对此进行了改进，在进行多次垃圾回收之后，会紧跟着进行一次内存碎片的整理。

### G1垃圾回收器
G1全称叫做Garbage First。G1垃圾回收器是一个应用于整个堆上的垃圾回收器，它的实现方式跟其他垃圾回收器的实现方式有较大差别。
讲到分代垃圾回收算法会针对不同的分代采取不同的回收策略。分代垃圾回收避免了每次都对整个堆进行垃圾回收，缩短了垃圾回收的时间，进而缩短了STW时间。借鉴分代的处理思路，G1垃圾回收器将整个堆划分为很多（一般是2048个）小的区域（Region），其中，一部分区域归为年轻代（Eden区或Survivor区），一部分区域归为老年代，各个分代中的内存并不是连续的。

之前的垃圾回收器都是针对整个分代进行垃圾回收的，要么是整个年轻代，要么是整个老年代，因为要回收的内存空间比较大，所以，垃圾回收时间也比较长。当年轻代和老年代被划分为更多更小区域之后，当进行垃圾回收时，虚拟机可以只回收分代中的部分区域，进一步缩短了STW时间。当然，G1垃圾回收器跟CMS垃圾回收器类似，也是使用多线程进行垃圾回收的，并且，回收的过程可以跟应用程序并发执行。在G1垃圾回收器中，年轻代和老年代的垃圾回收都使用标记-复制算法，只有触发 Full GC 才会采用标记-整理算法
跟其他垃圾回收器相比，G1垃圾回收器的STW时间是可预期的，可以通过JVM参数-XX:MaxGCPauseMillis设置可允许的最大STW时间。G1垃圾回收器会根据这个时间来决定每次对多少个区域进行垃圾回收。理论上讲，STW时间设置的越小，每次进行垃圾回收的区域就越少，垃圾回收的频率就越高。

## 垃圾回收器的对比与选择
以上介绍了4类常用的垃圾回收器，在默认情况下，Java7、Java8均采用Parallel垃圾回收器，Java9采用G1垃圾回收器。当然，也可以通过设置JVM参数来指定项目所使用的垃圾回收器，具体如下所示。
~~~
垃圾回收器      JVM参数设置                 年轻代                 老年代
Serial         -XX:+UseSerialGC            Serial New            Serial Old
Parallel       -XX:+UseParallelGC          Parallel Scavenge     Parallel Old
CMS            -XX:+UseConcMarkSweepGC     Parallel New          CMS
G1             -XX:+UseG1GC                G1                    G1
~~~

在实际的项目中，该如何选择使用哪种垃圾回收器呢？
Serial垃圾回收器使用单线程进行垃圾回收，在多核系统下，它无法发挥多核的优势，但是，在单核系统下，因为其实现比较简单，相对于Parallel垃圾回收器，Serial垃圾回收器省去了线程切换的开销，执行更加高效，因此，Serial垃圾回收器常用于三种情况下：在单核系统下、多个应用程序争用CPU资源的情况下、需要刻意限制虚拟机所占用资源的情况下。比如，运行在移动端的客户端程序一般会采用Serial垃圾回收器，这类程序所占用内存空间往往比较小，并且垃圾回收不会耗时很多，因此，Serial垃圾回收器足够应付。
Parallel垃圾回收器跟CMS垃圾回收器相比，前者吞吐量更大，后者停顿时间更少。对于离线系统，首选吞吐量大的Parallel垃圾回收器。对于实时系统，特别是对响应时间比较敏感的系统，首选停顿时间更少的CMS垃圾回收器。
在Java9中，CMS垃圾回收器被标记为Deprecated（即不推荐使用），取而代之的是G1垃圾回收器。特别是对于堆比较大（大于6GB）的情况，应该首选停顿时间可控的G1垃圾回收器。

## 为什么说G1比起CMS等垃圾回收器更加适合比较大的堆的垃圾回收呢？
使用cms在回收老年代对象的时候使用标记清除，并且多次清除后会串行整理内存碎片，内存空间越大大，此时STW时间越长，体验越不好。
相反G1可以自己定义STW时间，即便堆很大，系统还能保持在一个稳定运行的状态。
从上面也可以看到，CMS的底层设计决定了它在稳定性上有致命的缺点，随着计算机发展，内存空间变大是必然趋势，G1垃圾回收器相比下底层设计，性能和稳定性综合看都是要比CMS强的，这也是为什么CMS后续被标记为不推荐使用，实际上就是要逐渐淘汰CMS

## CMS和G1的并发垃圾回收是如何实现的？
需要注意的是，这里所说的并发垃圾回收并非完全不需要暂停应用程序，而是在大部分时间里都不需要暂停应用程序。并发垃圾回收将垃圾回收的整个过程分为4个阶段：初始标记、并发标记、重新标记、并发清理。其中并发标记和并发清理这两个比较耗时的阶段可以与应用程序并发执行，而初始化标记和重新标记这两个阶段仍然需要暂停应用用程序的执行。
初始标记指的是标记GC Roots，并发标记指的是在应用程序不暂停的情况下，以GC Roots为起点，广度优先或深度优先遍历所有可达对象（也即存活对象）。在并发标记的过程中，应用程序有可能修改对象之间的引用关系，导致并行标记过程出现误标或漏标的情况。重新标记所做的工作就是对误标或漏标进行修正。并发清理指的是在不暂停应用程序的情况下，对标记出来的垃圾对象进行清理。
在以上4个阶段中，初始标记、并发标记、重新标记这三个阶段属于可达性分析环节，也就是标记-清除算法中的标记环节。并发清理是标记-清除算法中的清除环节。接下来，就来详细讲解一下这4个阶段是如何实现的。

### 三色标记算法
可达性分析基于三色标记算法来实现，它将遍历过程中的对象分别标记为：白色、灰色、黑色三种类型。各个颜色的含义如下所示
- 白色表示对象没有被遍历过。在遍历开始时，所有的对象都是白色，但当遍历结束后，如果对象仍为白色，那么就表示对象不可达
- 灰色表示对象已经被遍历但对象所直接引用的对象还没有完全被遍历
- 黑色表示对象已经被遍历并且对象所直接引用的对象都已经被遍历

前面讲到，可达性分析是基于图的广度或深度优先遍历算法来实现，拿广度优先遍历算法来举例讲解，在遍历的过程中，对象颜色的标记和转换具体如下所示。
1. 将GC Roots标记为灰色并放入灰色集合，将其他节点标记为白色并放入白色集合
2. 从灰色集合中取一个灰色对象，将其标记为黑色并放入黑色集合，然后，将此对象直接引用的所有白色对象标记为灰色并放入灰色集合
3. 重复上述第2步，直到灰色集合中没有对象为止。此时，黑色集合中存放的就是可达对象，也就是存活对象，白色集合中存放的就是不可达对象，也就是死亡对象
在上述的处理过程中，步骤1被称为初始标记阶段，步骤2和3在并发垃圾回收中，可以与应用程序并发执行，因此，被称为并发标记阶段。举例解释一下上述处理过程，具体如下图所示。

### 增量更新和原始快照
误标是可以接受的，它只会导致垃圾对象延迟回收，本该在本轮回收的对象在下一轮垃圾回收中被回收。漏标是不可以接受的，本不该被回收的对象被回收，这就会导致应用程序的运行出错，因此，漏标是重新标记要解决的重点问题。
总结一下漏标产生的原因，主要有以下两点。这两点缺一不可。
- 新增引用：新增一个黑色对象对一个白色对象的引用
- 删除引用：删除所有灰色对象到此白色对象的直接或间接的引用
针对以上两点，Java发明了两种漏标解决方案：增量更新和原始快照。实际上，这两种解决方案的处理思路是类似的，只不过，增量更新记录的是新增的引用关系，原始快照记录的是删除的引用关系。CMS垃圾回收器使用增量更新解决漏标问题，G1垃圾回收器使用原始快照解决漏标问题。
1. 增量更新
在并发标记的过程中，如果应用程序新增了一个黑色对象对一个白色对象的引用，那么，虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下的白色对象为起点，重新进行可达性分析。这样漏标的白色对象会被重新标记为黑色对象。
2. 原始快照
在并发标记的过程中，如果应用程序删除了一个灰色对象对一个白色对象的直接引用或间接引用，那么，虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下来的白色对象为起点，重新进行可达性分析。这就相当于虚拟机对引用关系改变之前的原始快照进行可达性分析。
不过，使用原始快照记录下的白色对象有可能是死亡对象，而重新标记阶段会将这些死亡对象重新标记为存活对象，因此，原始快照这种解决方案会导致误标问题，不过，前面讲到，误标是可以接受的。

### 并发清理
为什么并发清理阶段可以跟应用程序并发执行？
在并发清理阶段，对象的引用关系也有可能发生改变。存活对象有可能会变为死亡对象，但这些对象只需要在下一次垃圾回收中被回收即可。

反过来，死亡对象是否有可能会变为存活对象，从而导致清理操作将存活对象清理掉呢？
答案是不会。死亡对象不再有变量（局部变量或静态变量）的直接或间接引用，因此，应用程序是无法在代码中使用这些死亡对象。如下代码所示。函数内创建的对象，在函数内部可以使用，这是因为有局部变量的存在，可以通过局部变量来访问这个对象。但是，在函数执行结束之后，局部变量被销毁，没有变量直接或间接的引用这个对象，也就无法在代码中访问这个对象了。
~~~java
public void f() {
  Student stu = new Student();
  stu.age = 19;
  stu.name = "hhh";
}
~~~

如果在并发清理的过程中，应用程序创建了新的对象该怎么办呢？实际上，解决方法很简单：直接将新创建的对象标记为黑色，即存活对象。这种处理方案同样适用于并发标记阶段。当然，这也有可能会导致误标问题。


G1 垃圾回收器，无论是「年轻代」还是「老年代」，都是采用「并发标记+复制」算法，只有在触发 Full GC 才会采用「标记-整理」算法

