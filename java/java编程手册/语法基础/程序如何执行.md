# 解释型、编译型、混合型语言
- CPU只认识机器指令（也叫做CPU指令、机器码），使用高级语言（Python、C++、Java等）编写的代码，需要编译（编译的意思实际上就是“翻译”）为机器指令之后，才能被CPU执行。不同编程语言的编译过程是不同的。根据编译过程的不同，我们将编程语言分为解释型、编译型、混合型语言三类

### 编译型语言
对于类似C，C++，Go这样的编译型语言，代码会事先被编译成机器指令（可执行文件），然后再一股脑儿交给CPU来执行。在执行时，CPU面对的是已经编译好的机器指令，直接逐条执行即可，执行效率比较高。但因为每种类型的CPU（比如AMD、ARM等）支持的CPU指令集不同，并且程序还有可能调用特定操作系统提供的API，所以，编译之后的可执行文件只能在特定的操作系统和机器上执行，换一种操作系统或机器，编译之后的可执行文件就无法执行了。

### 解释型语言
- 对于类似Python，JavaScript这样的解释型语言，代码并不会被事先编译成机器指令，而是在执行的过程中，由Python虚拟机（也叫做解释器）逐条取出程序中的代码，然后编译成机器指令，交由CPU执行，执行完成之后，再取出下一条代码，重复上述的编译、执行过程。这种一边编译一边执行的过程，叫做解释执行。
- 解释型语言相对于编译型语言，执行速度会慢一些。因为程序是在执行的过程中一边编译一边执行的，所以，程序整体的执行时间包含了程序编译的时间。不过，相对于使用编译型语言编写的代码，使用解释型语言编写的代码的可移植性更好。程序在执行的过程中，虚拟机可以根据当前所在机器的CPU类型和操作系统类型，翻译成不同的CPU指令。这样，同一份代码就可以运行在不同类型的机器和不同类型的操作系统上。这就是常听到的“一次编写，多处运行”。

### 混合型语言
- Java语言比较特殊，它属于混合型语言，既包含编译执行也包含解释执行。
- Java编译器会先将代码（.java文件）编译成字节码（.class文件）而非机器码。字节码是Java代码和机器码之间的一种中间状态，它既跟平台无关，又可以快速地被翻译成机器码。编译之后的字节码在执行时，仍然是解释执行的，也就是字节码被逐行读出，然后翻译成机器码，再交给CPU执行。只不过，从字节码到机器码的翻译过程，比从高级语言到机器码的翻译过程，耗时要少。这样既保证了Java代码的可移植性（同一份代码可以运行在不同的CPU和操作系统上），又避免了解释执行效率低的问题。
- 实际上，在解释执行的过程中，Java虚拟机会将热点字节码（反复多次执行的代码，类似缓存中的热点数据），编译成机器码缓存起来，以供反复执行，这样就避免了热点字节码需要反复编译，进一步节省了解释执行的时间。这就是著名的JIT编译（Just In Time Compile，即时编译）

# CPU、操作系统、虚拟机

### CPU的作用
- CPU的工作非常明确，用来执行编译好的机器指令

### 操作系统在程序执行中的作用
- 早期的计算机还没有高级语言和操作系统，程序员使用机器指令编写代码，并将代码通过纸带打卡方式记录下来，然后传输给计算机（可以理解为CPU）直接执行。
- 随着硬件资源越来越丰富，计算机开始集成各种硬件设备，比如内存、硬盘、各种输入输出（键盘、鼠标、显示器等），并且，人们希望多个程序能在计算机中并发执行（比如听歌的同时还能打字），于是，操作系统就诞生了。
- 操作系统用来管理硬件资源和调度程序的执行。打个比如，CPU等硬件就好比车间中的机器，工人就好比操作系统，一个个程序就像一个个待执行的任务。工人（操作系统）调度机器（CPU等硬件）来执行各个任务（程序）。
- 除此之外，操作系统还担当了类库的作用。对于通用的功能代码，比如读写硬盘等，没必要在每个程序中都从零编写一遍。操作系统将这些通用的功能代码，封装成API（专业名称叫做系统调用），供我们在编写应用程序时直接调用。也就是说，在应用程序的执行过程中，CPU可能会跳转去执行操作系统中的某段代码。

### 虚拟机在程序执行中的作用
对比一下C++、Python、Java这三种语言的编译命令和执行命令，如下所示。
~~~shell
// C++
$ g++ helloword.cpp -o helloworld
$ ./helloword

// Python
$ python helloworld.py

// Java
$ javac HelloWorld.java
$ java HelloWorld
~~~

- 仔细观察上述命令行的区别，我们可以发现，C++编译之后的代码直接就可以执行，而Python和Java代码的执行，需要依赖其他程序（即虚拟机），表现在命令行中就是执行命令前面有python、java字样。
- 对于使用解释型和混合型语言编写的代码，其执行过程都需要虚拟机的参与。实际上，虚拟机本身也是一个程序，而且它已经是CPU可以执行的机器指令了。程序员编写的代码相当于嵌套在虚拟机程序中的一个插件（或者功能模块），只不过，它跟虚拟机本身的代码有点不同，无法直接交给CPU执行。CPU执行虚拟机代码将应用程序的字节码翻译成CPU指令，放到固定的内存位置，再通过修改IP寄存器（Instruction Pointer Register寄存器存储CPU将要执行的指令位置），引导CPU执行这块内存中存储的CPU指令。
- JVM虚拟机的解释执行是将字节码转化成CPU指令再执行。
- 站在操作系统和CPU的角度，Java程序编译之后的字节码跟虚拟机合并在一起，才算是一个完整的程序，才相当于C++编译之后的可执行文件。CPU在执行程序员编写的代码的同时，也在执行虚拟机代码，并且是先执行虚拟机代码，然后才引导执行程序员编写的代码。

# CPU指令、汇编语言、字节码

### CPU指令
- 我们经常说的CPU指令、机器码、机器指令，实际上都是一个东西，就是CPU可以执行的操作。一条CPU指令包含的信息主要有：操作码、地址、数据三种，分别指明所要执行的操作、数据来源或去向、数据本身。
- 一组CPU指令的集合，叫做指令集。常见的指令集有X86、X86-64、ARM、MIPS等。不同的CPU支持的指令集可能不同（Intel CPU支持X86指令集，ARM CPU支持ARM指令集）。当然，不同的CPU支持的指令集也可以相同（比如Intel和AMD的CPU都支持X86和X86-64指令集）。同一个CPU也可以支持多个指令集（比如Intel CPU支持的指令集有X86、X86-64以及其他扩展指令集）。CPU支持的指令集一般都非常庞大，例如Intel CPU支持的指令集共包含2000多条指令，可以完成诸多不同类型的操作。

### 汇编语言
- 在计算机发展的早期，程序员直接使用机器码来编写程序。但是，因为机器码是二进制码，所以，编写起来复杂、可读性也不好。为了解决这个问题，于是，计算机科学家就发明了汇编语言。汇编语言由一组汇编指令构成。汇编指令跟CPU指令一一对应，但汇编指令采用字符串而非二进制数来表示指令，因此，其可读性好很多。实际上，CPU指令和汇编指令之间的关系，就类似IP地址和域名之间的关系。IP地址和域名一一对应，域名的可读性比IP地址好。
- 程序员使用汇编语言编写的代码，需要经过编译，翻译成机器码才能被CPU执行。为了跟其他类型的编译过程区分，我们把汇编语言的编译过程叫做“汇编”。C/C++语言的编译过程，实际上也包含汇编这一过程。编译器会先将C/C++代码编译成汇编代码，然后再汇编成机器码。
- 汇编语言主要有两种语法格式，一种是Intel风格的，一种是AT&T风格的。拿一段C语言代码来举例，如下所示，汇编代码是Intel风格的。注意上述汇编代码中的注释以分号开头。对于没学习过汇编语言的同学，完全理解上述汇编代码可能比较困难。
~~~
// hello.c
#include <stdio.h>

int main() {
  int a = 1;
  int b = 2;
  int c = a + b;
  return c;
}
~~~

上述代码编译成汇编代码，如下所示：
~~~
$ gcc -S -masm=intel hello.c
$ cat hello.s
_main:                                  ## @main
	.cfi_startproc
## %bb.0:
	push	rbp
	.cfi_def_cfa_offset 16
	.cfi_offset rbp, -16
	mov	rbp, rsp
	.cfi_def_cfa_register rbp
	mov	dword ptr [rbp - 4], 0  ;安全word，没有实际意义
	mov	dword ptr [rbp - 8], 1  ;int a = 1; 存储在栈中rbp-8的位置
	mov	dword ptr [rbp - 12], 2 ;int b = 2; 存储在栈中rpb-12的位置
	mov	eax, dword ptr [rbp - 8] ;a的值累加在寄存器eax上
	add	eax, dword ptr [rbp - 12] ;b的值累加在寄存器eax上
	mov	dword ptr [rbp - 16], eax ;int c = a+b
	mov	eax, dword ptr [rbp - 16] ;return c。返回值通过eax返回给上层。所以，把c值赋值给eax。因为上一句指令结束之后，有可能还有其他运算还会用到eax（本程序比较简单，没有其他运算了），所以eax中的值有可能会被改变，所以程序返回时重新将c值重新赋值给eax。
	pop	rbp
	ret
~~~


### 字节码
- Java语言是跨平台的，"write once, run anywhere"（一次编写，多处运行）。程序员编写的代码，在不需要任何修改的情况下，就可以运行在不同的平台（不同的操作系统和CPU）上。
- 字节码诞生的目的是，克服解释型语言解释执行速度慢的缺点（字节码是介于高级语言和机器码之间的形态，比高级语言解释执行更快）。
- 之所以Java语言能做到跨平台，最根本原因是有虚拟机的存在。Java代码跟平台无关，字节码跟平台无关，在编译执行过程中，总要有一个环节跟平台有关，不然，跟平台有关的、最终可以被CPU执行的机器码从何而来呢。俗话说的好，哪有什么岁月静好，只是有人帮你负重前行。跟平台有关的环节就是将字节码解释执行的环节，而这个环节的主导者就是虚拟机。
- 虚拟机是已经编译好的可以被CPU执行的机器码，而机器码又是跟平台有关的，因此虚拟机必须跟平台有关。这也是为什么针对不同的平台（操作系统和CPU），我们需要下载不同的Java虚拟机的原因。
- 使用javac命令编译之后，会得到一个后缀为.class的文件，这个文件里保存的一堆二进制码就是字节码。为了方便查看，我们用vi编辑器将其打开，然后转化成16进制格式之后。按照固定格式，例如，前4个字节为魔数（Magic Number），其值为固定值：0xCAFEBABE，用以标识此文件为字节码文件。紧跟着的4个字节表示Java编译器的版本，也就是JDK版本（major version和minor version），当然还有其他区域的划分就不详细介绍了，需要查看java虚拟机字节码规范
- 二进制文件是交给虚拟机解析的，人类阅读起来非常费劲。我们可以使用javap工具，将二进制格式的class文件解析成适合人类阅读的格式，我们把这个过程被叫做反编译
- class文件为什么叫字节码？跟字节（byte）有什么关系呢？从上述字节码中，我们可以发现，有些字节码指令包含操作码和操作数两部分，而有些只包含操作码这一部分。因为操作码长度为一个字节，所以，这种指令格式被叫做字节码。从另一个角度，我们也可以得知，字节码的操作码类型不超过256个（2^8）。相对于CPU指令和汇编指令，字节码指令少很多。这是因为字节码指令相对于CPU指令来说，抽象程度更高。一条字节码指令完成的逻辑，比一条CPU指令完成的逻辑，更加复杂


# 代码是如何被CPU执行的？
- 不管是使用哪种类型的编程语言（编译型、解释型、混合型）编写的代码，也不管经历什么样的编译、解释过程，最终交由CPU执行的都是机器码。
- 讲到CPU，我们就不得不讲一下寄存器。我们知道，内存的读写速度比起CPU指令的执行速度要慢很多。从内存中读取32位二进制数据所耗费的时间，相当于CPU执行上百条指令所耗费的时间。所以，CPU在执行指令时，如果依赖内存来存储计算过程中的中间数据，那么，CPU将总是在等待读写内存操作的完成，势必会影响CPU整体的计算速度。为了解决这个问题，于是，计算机科学家便发明了寄存器。

## 寄存器
- 寄存器读写速度非常快，能够跟CPU指令的执行速度相匹配。所以，内存中的数据会先读取到寄存器中再参与计算。不过，你可能会说了，数据在计算前需要先从内存读取到寄存器，计算之后存储在寄存器中的结果需要再写入内存，因此，寄存器的存在并没有避免掉内存的读写，那么，使用寄存器是不是多此一举呢？实际上，尽管最初数据来源于内存，最后计算结果也要写入内存，但中间的计算过程涉及到一些临时结果的存取，都可以在寄存器中完成，不需要跟非常慢速的内存进行交互。顺便说一句，计算机为了提高CPU读写内存的速度，还引入了L1、L2、L3这三级缓存。
- 为了做到能让CPU高速访问，寄存器的硬件设计比较特殊（高成本、高能耗），且相对于内存来说与CPU距离更近（寄存器直接跟CPU集成在一起），这些也决定了寄存器的个数不会很多。不同的CPU包含的寄存器会有所不同。常见的寄存器有以下几类。

### 通用寄存器：AX，BX，CX，DX
通用寄存器区别于下面要讲到的特殊寄存器，它们一般用来存储普通数据。AX，BX，CX，DX这四种通用寄存器的用途有所区别，比如AX是累加器

### 指针寄存器：BP，SP，SI，DI，IP
- BP（Base Pointer Register）和SP（Stack Pointer Register）是用于存储栈空间地址的寄存器，SP存储栈顶地址，BP比较特殊，一般存储栈中一个栈帧的栈底地址。这一部分在下一节讲解函数的执行过程时再详细讲解。
- SI（Source Index Register）源地址寄存器和DI（Destination Index Register）目的地址寄存器，分别用来存储读取和写入数据的内存地址。IP（Instruction Pointer Register）指令指针寄存器用来存储下一条将要执行的指令的内存地址的一部分。
- 段寄存器：CS，DS，SS
  - 程序由一组指令和一堆数据组成。指令存储在一块被称为代码段的内存中，由CPU逐一读取执行。数据存储在一块被称为数据段的内存中。指令执行的过程中，CPU会操作（读取或写入）这块内存中的数据。
  - CS（Code Segment Register）代码段地址寄存器存储了代码段的起始地址。上文中讲到，IP寄存器中存储的是下一条将要执行的指令的内存地址的一部分。CS和IP两个寄存器中存储的内容如下计算，才能得到一个真正的物理内存地址。
    - 物理内存地址 = 段地址（如CS） * 16 + 偏移地址（如IP）
    - 我们拿8086 CPU（早期的16位的X86 CPU）举例解释。8086 CPU具有20位地址总线，支持1MB内存的寻址能力。而16位的IP寄存器只能存储64K（2^16）个内存地址，一个字节占一个地址，因此，16位的IP寄存器只能支持64KB大小内存的寻址。为了扩大寻址能力，满足X86 CPU 1MB内存的寻址能力，计算机使用段地址和偏移地址相结合的方式来确定一个物理内存地址。通常，我们把CS寄存器和IP寄存器统称为PC寄存器，实际上，PC寄存器是一个抽象概念，并不真正存在这种寄存器。最大段地址=2^16-1，最大偏移地址=2^16-1，最大寻址=(2^16-1)*16 + (2^16-1) = 2^20+2^16-16-1 > 2^20=1M
  - DS（Data Segment Register）数据段地址寄存器存储了数据段的起始地址，它跟DI或SI结合才能确定一个数据段中的内存地址。
  - SS（Stack Segment Register）栈寄存器存储的是栈的起始地址，它跟SP结合确定栈顶的内存地址，跟BP结合确定栈中某个中间位置的内存地址。
- 指令寄存器：IR（Instruction Register）指令寄存器用来存放当前正在执行的指令。指令为一串二进制码，指令译码器需要从指令中解析出操作码和操作地址或操作数。所以，指令需要暂存在指令寄存器中等待译码处理。
- FR（Flag Register）标志寄存器，也叫做程序状态字寄存器（Program Status Word，PSW）。在这个寄存器中，每一个二进制位记录一类状态。比如cmp指令的运算结果会存储在ZF零标志位或CF进位标志位中。当cmp指令执行完成之后，CPU读取标志寄存器中的ZF位或CF位，便可以得到cmp指令的执行结果。
- 注意，以上讲解的是16位的寄存器，32位的寄存器名称在对应的16位寄存器名称前加E（例如EAX，EBP，ESP，EIP），64位的寄存器名称在对应的16位寄存器名称前加R（例如RAX，RBP，RSP，RIP）。在下一节中，在讲解编程语言基本语法的底层实现原理时，我们还会提到更多寄存器的使用细节。

### 了解了CPU指令执行的重要部件寄存器之后，我们来看下CPU指令执行的具体流程。
- 对于编译型语言，操作系统会把编译好的机器码，加载到内存中的代码段，将代码中变量等数据加载到内存中的数据段，并且设置好各个寄存器的初始值，如DS、CS等。IP寄存器中存储代码段中第一条指令的内存地址相对于CS的偏移地址。CPU根据PC寄存器（CS寄存器和IP寄存器的总称）存储的内存地址，从对应的内存单元中取出一条CPU指令，放到IR指令寄存器中，然后将IP寄存器中的地址加上offset，从而得到下一条指令的内存地址。对于16位CPU，一条指令的长度为2字节，一个字节占一个地址，因此，offset为2。同理，对于32位和64位CPU，一条指令的长度分别为4字节和8字节，因此，offset分别为4和8。一条指令执行完成之后，再通过PC寄存器中的地址，取下一条指令继续执行。循环往复，直到所有的指令都执行完成。
- 对于解释型或混合型语言，操作系统将虚拟机本身的机器码，加载到内存中的代码段。CPU执行虚拟机代码，将程序编写的代码解释为机器码，并放入某块内存中，然后将PC寄存器的地址设置为这块内存的首地址，于是，CPU就被虚拟机引导去执行程序员编写的代码了。


