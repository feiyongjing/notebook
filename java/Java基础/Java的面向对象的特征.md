# ⾯向对象的三⼤特征
- 封装
- 继承
-  多态

# 什么是封装？
封装隐藏了内部实现细节，只暴露出接⼝

# 什么是继承 ？
复用父类的代码，子类扩展出的新的功能，继承的本质是提炼出公⽤代码，避免重复

# 什么是多态？
- 在同一个方法因参数类型的不同导致执行结果各异的现象
  - 实例⽅法默认是多态的
  - 在运⾏时根据this即方法的接收者来决定调⽤哪个⽅法
  - 静态⽅法没有多态
- 参数静态绑定（参数引用的类型决定），接收者动态绑定（接收者的引用实际类型决定）
  - 例子 ：https://github.com/frank-0908/polymorphism-overload-method-selection.git
  - 多态只对⽅法的接收者⽣效，多态只选择接受者的类型，不选择参数的类型 


# 不封装会怎么样？
- 暴露细节的结果就是⽆法变化，改变一处则所有依赖它的地方都需要改变会使程序不稳定
  - 软件的演进栗⼦：为原先的属性增加限制
  - 软件的演进栗⼦：修改某些属性

# 封装的常见实现
- 访问控制符
  - public 任何⼈都能访问
  - protected 只有⼦类可以访问和同⼀个包的类可以访问
  - package private 只有同⼀个包的类可以访问   不声明默认为package private
  - private 只有⾃⼰可以访问

# JavaBean约定
- getter
- setter

# JDK9之后引入了模块化
- 了解：Java Platform Module System

# Java的继承体系
单根继承，一个类只有继承一个父类，如果不写继承类则默认继承Object，Object是所有类的父类

# 单根继承有什么好处？
所有的对象都有其父类的行为，如所有的类都有Object的行为

# 多根继承有什么问题？
一个子类继承两个或多个父类中有同名的方法时，子类对象调用这个方法时不知道调用那个父类中的方法

# 类的结构与初始化顺序
- ⼦类拥有⽗类的⼀切数据和⾏为
- ⽗类先于⼦类被创建出来
- 必须拥有匹配的构造器
  - 父类的构造器  
  - 子类的构造器的必须第一行代码通过 super(父类构造器的参数列表)  调用父类的构造器先创建父类对象

# super关键字
调⽤⽗类的⽅法（包括构造函数）

# 实例⽅法的Override，⼜称为覆盖/重写
- 子类覆盖了父类中同名的方法，永远使⽤@Override注解来防⼿残
- 方法重写要注意的事项
  - 方法名与形参列表必须一致。
  - 子类的权限修饰符必须要大于或者等于父类的权限修饰符。
  - 子类的返回值类型必须要小于或者 等于父类的返回值类型。
  - 子类抛出的异常类型要小于或者等于父类抛出的异常类型。 Exception(最坏) RuntimeException(小坏)

# 向上/向下转型
- ⼀个⼦类类型的对象永远是⼀个⽗类类型的对象
- 当需要⼀个⽗类型时，总可以传递⼀个⼦类型
- 但是，有的时候你必须进⾏⼀些转型
  - 使用（）进行强制类型转换，注意强制转型可能是不安全的

# final关键字
- final声明变量，变量成为不可变的（必须初始化）一但赋值不可改变引用
- final在⽅法上的声明：禁⽌继承/覆盖/重写此⽅法
- final在类声明上的使⽤：禁⽌继承此类
 
# 继承提供了灵活性，也埋下了隐患
栗⼦：为什么String/Integer等类是final的？
根据⼀个⼦类类型的对象永远是⼀个⽗类类型的对象，可以通过继承String来恶意的重写一些方法，然后需要使用父类对象的时候传递恶意写好的子类对象破坏程序的正常运行
 

 