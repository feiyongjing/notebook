### 问题：如何禁⽌默认实现？

 - 抛出异常
 - 抽象化
 - 抽象类
 - 接⼝
 
### 抽象方法

- 使用abstract修饰的方法
- ⾮private/static
- 不包含方法体的方法

### 抽象类

- 使用abstract关键字修饰的类为抽象类
- 不可实例化
- 可以实例化的子类⼀定要补全所有的⽅法体。
- 可以包含抽象⽅法也可以不包含
- 可以包含普通类的任何东⻄
-  抽象类能使用 final 修饰吗？
  -  不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承

### 接口
- 接⼝
 - 接⼝部分的实现了多继承
 - 接⼝不是类
 - 接⼝的实现类可以扩展接口
 - 接⼝只代表⼀种功能
 - ⼀个类只能继承⼀个类，但是却能实现若⼲的接⼝
- 接⼝可以包含什么？
  - 若⼲个⽅法（默认是public abstract，并且只能是pubilc）
  - 若⼲个常量（默认public static final,并且只能是public static final）
  - 可以**继承**其他的接⼝
  - Java8之后默认⽅法
     - 在方法前添加default修饰 可以在接口中添加方法体
     - 带来的问题
     - 当一个类实现了多于一个（比如两个）接口，而这些接口又有同样的default方法或者一些是抽象方法的时候，事情就变得很复杂了。类继承的是哪一个default方法呢？
         - 哪一个也不是！在这种情况下，类要自己（直接或者是继承树上更上层的类）来实现default方法（才可以）
     - Since Java 8
     - 是⼀种妥协的产物
     - 可以⽤来实现mixin
     - 菱形继承

### 接口与抽象类的区别？
   - 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
   - 构造函数：抽象类可以有构造函数；接口不能有。
   - main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。
   - 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
   - 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符
### 内部类
 - ⽤途：实现更加精细的封装
 - 可以访问外围类的实例⽅法
 - ⾮静态内部类
  - 和⼀个外围类实例相绑定
  - 可以访问外围类实例的⽅法
 - 静态内部类
  - 不和外围类实例相绑定
  - 不可以访问外围实例的⽅法
 - 原则：永远使⽤静态内部类，除⾮编译报错

### 匿名内部类
- 直接通过new的⽅式创建的⽆名类
- 在字节码中是外围类的名字加$与数字命名
