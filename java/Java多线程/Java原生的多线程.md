# 线程的历史
Java从⼀开始就把线程作为语⾔特性，提供语⾔级的⽀持
Java是史上最先⽀持全⾯多线程的语⾔之⼀
---

# 为什么Java中的所有对象都可以成为锁？
所有的对象都继承Object，而Object含有wait()/notify()/notifyAll()⽅法

# 为什么需要多线程
- CPU太快并且现代CPU都是多核的
- Java的执⾏模型是同步/阻塞(block)的

# 多线程的优点
- 对于IO密集型应⽤极其有⽤
  - ⽹络IO（通常包括数据库）
  - ⽂件IO

# 多线程的缺点 
- 线程的昂贵
  1. CPU切换上下⽂很慢
  2. 线程需要占⽤内存等系统资源

# 多线程的使用
- 如果你的应⽤⼀天才⼏个⽤户，直接 new Thread().start()
- 如果你的应⽤负载很⾼，使⽤线程池:JUC包


# 线程有哪些状态？
线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。


创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。

就绪状态。当调用了线程对象的start方法之后，但是CPU的时间片还没有分盘给当前线程，需要等待CPU的时间片，此时处于就绪状态。另外在线程运行之后，从等待或者睡眠中回来之后，也会等待CPU的时间片，线程处于就绪状态。

运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。

阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。

死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 
---

# 开启⼀个新的线程
- new Thread()
  - Java中只有这么⼀种东⻄代表线程
  - start⽅法才能并发执⾏！run方法是等当前线程执行完了才执行下一行代码
  - 每多开⼀个线程，就多⼀个执⾏流
  - ⽅法栈(局部变量)是线程私有的
  - 静态变量/类变量是被所有线程共享的

# 多线程的问题
1. 安全：竞争条件/死锁
2. 协同：同时、随机执⾏的线程，如何让他们协同⼯作？

# 线程不安全的表现
1. 线程协调出错与数据错误，著名的HashMap的死循环问题
2. 死锁
   - 互斥条件：资源不能被共享，只能被一个线程占用。
   - 请求与保持条件：线程在持有资源的同时请求其他资源。
   - 不剥夺条件：资源只能由持有它的线程释放，不能被其他线程强制剥夺。
   - 循环等待条件：存在一个线程等待队列，其中的线程等待其他线程所持有的资源，而这些资源又被其他线程所等待。

# 如何保证线程安全
1. 原⼦性操作：AtomicInteger
2. 共享变量使用线程安全的类（Collections.synchronized将集合包装成线程安全的类、ConcurrentHashMap ...）或使用不可变的类Integer/String/....
3. Java原⽣的锁机制：synchronized 保证同一时间只能有一个线程进行操作
4. 破坏死锁的必要条件
   - 破坏互斥条件：读写分离，只允许一个线程修改而其他线程只能查看
   - 破坏请求与保持条件：线程在持有资源的同时请求其他资源时设置等待资源的时长，超过时长自动释放持有的资源
   - 破坏不剥夺条件：线程持有的资源过多时由监视线程释放一些资源
   - 破坏循环等待条件：所有线程按照相同的顺序获得资源
5. 使用Java.util.concurrent包

# synchronized同步块同步了什么东⻄？即锁住的是什么？
- synchronized在字节码层⾯的实现：monitorenter/monitorexit
- synchronized(⼀个对象) 把这个对象当成锁，当同步块的代码被执行完后会释放锁
- Static synchronized⽅法 把当前方法的Class对象当成锁
- 实例的synchronnized⽅法把该实例当成锁
- synchronized同步块结束的时候自动释放锁

# Java原⽣的协同机制：wait/notify/notifyAll
- wait() 方法 一个锁调用这个方法则当前线程进入等待状态直到被其他线程唤醒。一个锁要调用这个方法则首先要拿到这把锁即synchronized(锁)同步锁，在调用完这个方法后释放掉这把锁。
- wait(long timeout)方法 与wait() 方法类似 但设置了一个等待的时间限制，参数timeout问零则与wait() 方法一样无时间限制。
- wait(long timeout, int nanos)方法 与wait(long timeout)方法类似但更加精准 在参数timeout毫秒的基础上添加了参数nanos纳秒
- notify() 方法 一个锁调用这个方法则唤醒其他等待中线程的随机一个线程。一个锁要调用这个方法则首先要拿到这把锁即synchronized(锁)同步锁，在调用完这个方法后释放掉这把锁。
- notifyAll() 方法 一个锁调用这个方法则唤醒其他所有等待中的线程，被唤醒的线程会正常竞争这把锁。一个锁要调用这个方法则首先要拿到这把锁即synchronized(锁)同步锁，在调用完这个方法后释放掉这把锁。

# wait和sleep什么区别？
wait() 方法 一个锁调用这个方法则当前线程进入等待状态直到被其他线程唤醒。一个锁要调用这个方法则首先要拿到这把锁即synchronized(锁)同步锁，在调用完这个方法后释放掉这把锁。
 sleep() 方法 使当前的线程进入毫秒级别的睡眠，如果在synchronized(锁)同步块中则一直持有锁直到睡眠结束
