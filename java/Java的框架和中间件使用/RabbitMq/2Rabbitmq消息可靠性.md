# Rabbitmq消息如何保证的可靠性
- 生产者保证消息不丢失
- 服务端mq保证消息不丢失和消息不堆积
- 消费者保证消息不丢失


### 生产者如何保证消息不丢失 ？
RabbitMQ有Publisher Confirm和Publisher Return两种确认机制。开启确机制认后，在MQ成功收到消息后会返回确认消息给生产者。返回的结果有以下几种情况:
- 消息投递到了MO，但是路由失败。此时会通过PublisherReturn返回路由异常原因，然后返回ACK，告知投递成功，这种情况一般是交换机没有绑定到任何队列（生产者发送消息时写错交换机名称或者交换机就是没有绑定队列）
- 临时消息投递到了MO，并且入队进入内存，返回ACK，告知投递成功
- 持久消息投递到了MO，并且入队完成磁盘持久化，返回ACK，告知投递成功
- 其它情况都会返回NACK，告知投递失败


### 服务端mq如何保证消息不丢失？
RabbitMO实现数据持久化包括3个方面
- 交换机持久化保持到磁盘：创建交换机时设置Durability为Durable
- 队列持久化保持到磁盘：创建队列时设置Durability为Durable
- 消息持久化保持到磁盘，发送消息时设置Delivery mode 为 2 Persisent（spring默认就是设置的持久化），这样消息会保存到磁盘中

从RabbitMQ的3.6.0版本开始，就增加了LazyQueue的概念，也就是惰性队列。并且在3.12版本后，所有队列都是Lazy Queue模式，无法更改惰性队列的特征如下:
- 接收到消息后直接先存入磁盘（磁盘IO的速度相比之前先存内存然后写入磁盘有优化）而非内存，内存中只保留最近的消息，默认2048条
- 消费者要消费消息时才会从磁盘中读取并加载到内存
- 支持数百万条的消息存储

### 消费者如何保证消息不丢失？
为了确认消费者是否成功处理消息，RabbitMO提供了消费者确认机制(Consumer Acknowledgement)，当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitM0自己消息处理状态。回执有三种可选值:
- ack：成功处理消息，RabbitMO从队列中删除该消息
- nack：消息处理失败，RabbitMO需要再次投递消息
- reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息，看起来和返回ack是一样的结果，但是使用场景大多是消息有问题（例如格式不正确的情况）时使用

SpringAMQP已经实现了消息确认功能。并允许通过配置文件选择ACK处理方式，有三种方式:
- none：默认就是这个值，表示不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用
- manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活
- auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack.当业务出现异常时，根据异常判断返回不同结果:
    - 如果是业务异常，会自动返回nack
    - 如果是消息处理或校验异常，自动返回reject

消费者消息处理失败后的策略
在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现:
- RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式（一定不能使用这种，消息丢失不可取）
- ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队（不建议使用，因为重新入队还是大概率会失败）
- RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机（建议使用这种方式，重试多次依旧失败的消息需要人工处理）


### 消息的幂等性（消息只消费一次）
- 方案1：给每个消息都设置一个唯一id，利用id区分是否是重复消息:
    1. 每一条消息都生成一个唯一的id，与消息一起投递给消费者。
    2. 消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库
    3. 如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理  
- 方案2：结合业务逻辑，基于业务本身做判断。以实际业务为例：订单系统发送消息给支付系统，在进行支付前先查询订单状态，判断状态是否是未支付状态。只有未支付的订单才需要进行支付，其它状态不做处理，这样即使有重复的消息也不会重复支付，当然这是不可逆的状态变更业务场景比较简单，对于可逆的状态变更业务场景则需要判断是否达到一些前置条件，简单的比如一个电源的开关，状态可以在开和关之间来回变更，只需要判断现在操作的动作与电源的实际情况是否一致，如果不一致就执行操作，一致则不进行处理。更加复杂的场景如果出现循环的流程需要思考好流程图再进行动手开发

