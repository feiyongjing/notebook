# 为什么需要消息队列？
- 实现生产者和消费者之间的异步操作
- 流量控制，延时处理消息，做到用户的请求不丢失，削峰填谷降低服务器压力
- 将生产者与消费者进行解耦

# 如何选择消息队列？
常见的消息队列有RabbitMQ、RocketMQ、Kafka、Pulsar

# 消息队列协议有哪些？

 
### 单个队列和分区有什么区别？
多个消费者存在时，单个消费者只能消费单个队列的一部分的消息，并且消费者之间的竞争处理比较麻烦
分区中包含多个队列，支持对多个消费者的消息处理，解决了并发问题，但是带来了消费者组的重平衡问题

### 什么是重平衡？
解除消费者与分区的绑定，通过负载均衡算法来使消费者与随机分区再次的绑定

### 如何做到消息不丢失？
- 生产阶段：生产者发送消息给Broker(代理)后，Broker通过ACK(可靠消息机制)返回消息确定消息接收成功，并在消息队列中添加一条消息
- 存储阶段：使用多个Broker(代理)来确保当个Brocker挂掉之后其他的Broker能继续收发消息
- 消费阶段：消费者从Broker(代理)拉取消息后，消费者也通过ACK(可靠消息机制)返回消息确定消息拉取成功，并在消息队列中对应的消费者offset索引向后移动

### 怎么处理重复消费？
- At most once：最多消费一次，消费后offset索引向后移动，但是在处理消息时出现异常就相对于丢失了消息
- At least once：最少消费一次，消费后offset索引不移动，使其他的消费者能重复消费
- Exactly once：精确一次，添加事务保证消费一次，但是非常影响性能
- 伪Exactly once：精确一次，At least once+加幂等消费保证消费一次，幂等消费是在真正的消费前查询消息是否更新消费过，如果是则不消费，否则消费

### 消息是如何实现副本机制的？
通过主从选举实现的，对于一组Broker(代理)进行选举出 Leader(领导者) Broker 和 Follower(追随者) Broker
Leader Broker进行主要的接收消息和复制消息给其他的 Folloerwer Broker ，在Leader Broker 挂掉之后会立刻从 Follower Broker 中选取新的 Leader Broker
当Leader Broker 挂掉后，为避免信息大量的丢失，从Follower Broker 中根据 Log End Offset (日志末端偏移) 选举出 最高水位的成为Leader Broker 

 

 

 