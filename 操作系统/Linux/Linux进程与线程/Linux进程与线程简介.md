### 程序与进程、线程、协程
- 程序：编写好可执行的文件
- 进程：一个运行中的程序，内部至少有一个线程。进程是最小资源单位、线程是最小执行单位。一个进程中包含的多个线程共享进程的大部分内存空间（注意堆可以共享，而栈不能共享）
- 线程是轻量级的进程，协程理解为轻量级的线程即微线程
- 协程的作用是在执行函数A时可以随时中断去执行函数B，然后中断函数B继续执行函数A（可以自由切换）。但这一过程并不是函数调用，这一整个过程看似像多线程，然而协程只有一个线程执行。协程是运行在单线程当中的"并发"，协程相比多线程一大优势就是省去了多线程之间的切换开销，获得了更大的运行效率。协程可以处理IO密集型程序的效率问题，但是处理CPU密集型不是它的长处，如要充分发挥CPU利用率可以结合多进程+协程。协程不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。
- Linux内核是不区分线程和进程的，，进程和线程只是用户层面的区分。原因是线程和进程的创建都是调用的同一个系统函数 clone，区别只是进程的创建是复制了内存空间，线程是共享了内存空间

### 每个程序启动运行成进程都有一个pid，同一个程序多次启动会占用不同的pid

### 并发与并行
- 并发：指一个cpu上运行多个程序，例如1个cpu的时间片分配给多个程序使用
- 并行：指多个cpu在同一时间运行多个程序，例如多核心cpu在同一时间运行多个程序
- 总结：单核的cpu没有必要使用多线程

 
### 每个程序启动系统都会分配虚拟内存地址空间，虚拟地址空间分为内核空间和用户空间，其中内核空间是受系统保护的用户不能对其进行读写操作。

### 内核区中一个重要区域是PCB（本质是结构体），PCB中有文件描述符表，文件描述符表中存放了打开的文件描述符，涉及文件IO操作都会使用这个文件描述符
### 用户空间有环境变量、命令行启动参数、堆、栈、动态加载区、.txt（代码段）、.bss、.deta（数据段）等

### 每一个进程都至少打开了3个文件，标准输入、标准输出、标准错误分别代表进程的0、1、2编号文件描述符（它们的宏分别是STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO）。

### 注意标准输入、标准输出、标准错误的文件描述符不要使用close()关闭，否则可能会出现当前程序读取不到输入或者是输出无法显示在显示器上，当然使用重定向输入输出也有可能导致出现问题，例如  

~~~C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int fp=open(~/test.log, O_CREAT | O_RDWR); // 文件描述符fp指向 ~/test.log 文件
dup2(fp, STDOUT_FILENO);      // 关闭标准输出文件，同时将标准输出的文件描述符重定向到fp指向的~/test.log 文件
pringf("这句话会输出到~/test.log 文件，而不会输出到显示器上");

~~~
---
 
### 而一个进程最大只能打开1024个文件（这个是可以设置的），每次进程打开一个文件会在文件描述符表中挑选一个最小编号的文件描述符分配给进程，当然如果文件描述符被关闭就相当于这个文件描述符被回收了，下次分配进程文件描述符时可能使用被回收的文件描述符

 

# 程序内核区的PCB区域
每个程序在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体

源代码在  /usr/src/kernels/3.10.0-1160.76.1.el7.x86_64/include/linux/sched.h 中有这个结构体（不同的内核路径不同）

如果/usr/src/kernels下没有找到源码请安装与当前操作系统版本一致（通过uamne -a查看内核版本）的源码  yum install kernel-devel-(内核版本)

task_struct结构体过于庞大，以下是一些常见属性

- pid_t 属性是一个非负整数，表示进程ID号
- 进程的状态，有创建、就绪，运行，挂起（阻塞），停止状态。
  - 进程创建完成进入就绪状态
  - 就绪态等待cpu的时间片分配完成进入运行状态
  - cpu的时间片用完会从运行状态回到就绪状态，如果进程在运行状态中出现等待资源造成阻塞会进入阻塞状态
  - 阻塞状态的进程获取到了需要的资源或者SIGCONT信号量（继续运行）不会直接回到运行状态，而是回到就绪状态等待cpu的时间片，得到cpu的时间片之后重新进入运行状态
  - 就绪态进程收到SIGSTOP信号量（暂停运行）会暂停程序进入阻塞状态
  - 就绪，运行，挂起（阻塞）都可以直接到达停止状态，有内部原因程序出错、程序运行结束，外部原因例如手动 kill 杀死进程
- 进程切换时需要保存和恢复的程序寄存器地址，cpu切换时记录当前程序的一些数据，在cpu重新分配到这个程序后恢复这些数据继续执行程序
- 描述进程虚拟内存空间的信息
- 描述控制终端的信息
- 当前工作目录：就是进程启动时的目录
- umask掩码
- 文件描述符表：包含指向file结构体的指针（程序打开的文件file结构体指针）
- 和信号相关的信息：主要是阻塞信号集和未决信号集
- 用户id和组id：程序所属的用户id和组id
- 会话（session）和进程组：父进程和它的所有子进程都在同一个进程组中
- 进程可以使用的资源上限，ulimit -a 命令可以查看
 
