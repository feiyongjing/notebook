### 两个进程想要通信必须通过内核，其中一个进程将数据写入内核缓冲区，另一个进程从内核缓冲区读取数据，内核提供的这种进程间通信被称为IPC

### 进程通信的方式有很多，例如文件、管道、信号、共享内存、消息队列、套接字、命名管道等。其中常用的有
- 管道：使用简单，只能用于有血缘关系的进程通信
- 信号：资源开销最小
- 共享映射区：一般用于没有血缘关系的进程通信
- 本地套接字：最稳定
 

# 管道（pipe）
- 管道的本质是一块内核缓冲区，内部是环形队列实现的
- 管道有两个文件描述符引用，一个表示读端，另一个表示写端，规定数据从写端流入管道，从读端流出
- 管道的数据只能单向流通从读端到写端，如果需要双向流动则需要再开辟一个管道反向流通数据
- 管道只能用于有血缘关系的进程通信
- 当管道两端的进程都终结时，管道也会自动消失
- 管道的读和写默认都是阻塞的
- 管道中的数据一旦读走，管道中就不再有读走的数据，即不可反复读取
- 默认的管道缓冲区是4k，使用ulimit -a 可以查看
 

## 管道函数
查看命令：man 2 pipe

~~~C
#include <unistd.h>

    int pipe(int pipefd[2]);
    
#define _GNU_SOURCE /* See feature_test_macros(7) */
#include <fcntl.h> /* Obtain O_* constant definitions */
#include <unistd.h>

    int pipe2(int pipefd[2], int flags);
    
// pipe函数创建管道
// pipefd[2] 参数是两个长度的数组，第一个元素是管道的读端文件描述符、第二个元素是管道的写端文件描述符
// pipe函数返回值为0表示成功创建管道，返回-1表示失败并设置了 error 值
// 其实pipefd[2]的两个文件描述符在函数调用后，它们指向的是内核的缓冲区

~~~
---
 
## 父子进程使用管道通信
1. 创建管道
2. 创建子进程
3. 父进程关闭管道的一端，子进程关闭管道的另一端
4. 父子进程分别向管道读写数据
~~~C
#include <sys/types.h>
#include <sys/wait.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main(){

    pid_t p;
    int i;
    int fd[2];
    // 创建管道
    int ret = pipe(fd);
    
    if(ret<0){
        perror("创建管道失败\n");
        return -1;
    }

    p = fork();
    if(p<0){
        perror("创建子进程失败\n");
        return -1;
    }

    if(p>0){
        printf("只有父进程执行的逻辑代码，父进程的pid是%d，父进程的父进程pid是%d\n", getpid(), getppid());
        // 父进程关闭管道的读端
        close(fd[0]);

        sleep(5);
        printf("父进程第一次向管道写入数据\n");
        char hello[100] = "hello world";
        write(fd[1], hello, strlen(hello));

        sleep(5);
        printf("父进程第二次向管道写入数据\n");
        char hello1[100] = "hello world1";
        write(fd[1], hello1, strlen(hello1));
        
        // 关闭子进程
        wait(NULL);
    }

    if(p==0){
        printf("子进程执行的逻辑代码，子进程的pid是%d，父进程的pid是%d\n", getpid(), getppid());
        // 子进程关闭管道的写端
        close(fd[1]);

        char buf[100];
        // 管道文件默认是阻塞的，所以会等待管道写入数据后再读取数据
        read(fd[0], buf, sizeof(buf));
        printf("子进程从管道第一次读取的数据是：%s\n", buf);

        char buf1[100];
        read(fd[0], buf1, sizeof(buf1));
        printf("子进程从管道第二次读取的数据是：%s\n", buf1);
        return 88;
    }

    return 0;
}
~~~
---
 

 
