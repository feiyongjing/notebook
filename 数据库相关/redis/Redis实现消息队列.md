# 方式一  使用List数据结构的Lpush和Rpop

优点1：能够实现持久化

缺点1：如果队列空了，消费者会陷入pop死循环，即使没有数据也不会停止。空轮询不但消耗消费者的CPU资源还会影响Redis的性能。

缺点1的简要解决方案：让消费者的线程按照一定的时间间隔不停的循环和监控队列，虽然可行但显然会造成不必要的资源浪费，而且循环周期也很难确定。

缺点2：不停的调用rpop查看列表中是否有待处理的消息。每调用一次都会发起一次连接，势必造成不必要的资源浪费。如果使用休眠的方式让消费者线程间隔一段时间再消费，但这样做也有两个问题：

如果生产者速度大于消费者消费的速度，消息队列长度会一直增大，时间久了会占用大量内存空间。
如果休眠时间过长，就无法处理一些时效性的消息。如果休眠时间过短也会在连接上造成比较大的开销。
缺点3：不是可靠队列模式 ，没有ack 机制保证List 队列中的消息一经发送出去，便从队列里删除。如果由于网络原因消费者没有收到消息，或者消费者在处理这条消息的过程中崩溃了，就再也无法还原出这条消息。
缺点4：生产者生产的消息只能被一个消费者消费一次，不能被多个消费者消费多次
 
# 方式二  使用List数据结构的Lpush和Brpop

解决了方式一的缺点1和2，但是其他的缺点仍存在

# 方式三 使用List数据结构的Lpush和Brpoplpush

解决了方式一的缺点1、2、3，但是其他的缺点仍存在

# 方式四  使用Zset数据结构的Zadd和Zrem等等操作

订单创建的时候，订单ID和当前时间戳分别作为Sorted Set的member和score添加到订单队列Sorted Set中

解决了方式一的缺点1、2、4，但是又暴露了新的缺点

缺点1：不允许重复消息（因为是集合），同时消息ID确定有错误会导致消息的顺序出错

# 方式五  使用发布和订阅，即Publish统一发布，使用Subscribe订阅指定频道(key)或者使用Psubscribe订阅指定模式(正则匹配key)

解决了方式一的缺点1、2、4，但是又暴露了新的缺点

缺点1：消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。

缺点2：没有 Ack 机制来保证数据的可靠性，假设一个消费者都没有，那消息就直接被丢弃了。

缺点3：若消费者客户端出现消息积压，到一定程度，会被强制断开，导致消息意外丢失。通常发生在消息的生产远大于消费速度时 

# 方式六  使用Stream数据结构的Xadd、Xdel、Xrange、Xlen

 解决了方式四的全部缺点

参考：https://www.jianshu.com/p/d32b16f12f09

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 