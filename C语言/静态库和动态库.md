 

### 库函数是对系统函数的封装
- 库必须包含头文件和库实现
- 库分为静态库（ static library ）和动态库，一般是动态库使用的比较多

### 静态库
- 名称分为三部分：lib+库名称+文件后缀名（ 一般是 .a ），例如  libtest.a 
- 在使用静态库的程序是将库代码内嵌到了程序中，所以内存中可能加载了多份一样的库代码

### 动态库
- 名称分为三部分：lib+库名称+文件后缀名（ 一般是 .so ），例如  libtest.so 
- 在使用动态库的程序是将库代码加载到了内存中，而多个程序使用同一个动态库时会先在内存中找库是否加载，如果没有加载才加载，避免了空间的浪费
 

## 静态库的生成

### 步骤一：将 .c 文件后缀的源代码编译成 .o 文件
~~~shell
gcc -c test1.c test2.c [更多的源文件]
~~~
---

### 步骤二：使用打包工具 ar 将 .o 文件打包成 .a 文件
~~~C
ar rcs [静态库名称] [.o文件]
# r参数更新
# c参数创建
# s参数建立索引
~~~
---

## 动态库的生成

### 步骤一：将 .c 文件后缀的源代码编译成 .o 文件
~~~shell
gcc -fpic -c test1.c test2.c [更多的源文件]
# -fpic参数是创建与地址无关的编译程序，目的是为了能加载库到内存中，多个应用程序使用了一个库时可以共享同一个库不必二次加载
~~~
---

### 步骤二：使用gcc -shared 将 .o 文件打包成 .so 文件
~~~shell
gcc -shared test1.o test2.o -o [动态库文件名称，例如 libtest.so ]
~~~
---
 
## 使用库
获取库文件（ .a文件 ）和 它对应的头文件放入指定的路径下

~~~shell
gcc -c [使用库的源代码] -I [库的头文件目录] -L [库文件目录（ .a 或 .so文件目录 ）] -l [库名称]
# -I参数指定需要的头文件目录
# -L参数指定需要的库文件目录
# -l参数指定需要的库名称，注意去除库文件全名的前缀lib和文件后缀名 .a或者是 .so
~~~
---
 

### 查看可执行程序依赖的库文件
~~~shell
ldd [可执行程序]
~~~
---
 
### 对于ELF格式的可执行文件，它依赖的库由Id-Linux.so*完成的，它查找顺序是 可执行文件的DT_RPATH段、LD_LIBRARY_PATH环境变量、/etc/Id.so.cache文件列表、/lib、/usr/lib下查找库文件并加载到内存
~~~C
# 查看文件是否是ELF格式可执行文件
file [可执行文件]
~~~
---
 

### 添加库文件到Linux系统库中
- 建议修改环境变量，其他的方式不推荐
- LD_LIBRARY_PATH环境变量修改：一般修改 ~/.bashrc 配置文件

~~~C
# 环境变量添加库文件路径yyy
export LD_LIBRARY_PATH=￥LD_LIBRARY_PATH:yyy
~~~
---
 
