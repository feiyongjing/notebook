### 源文件后缀  .c 在windows下VS studio编译（编译器是  cl.exe）后的文件后缀是 .obj文件

### 源文件后缀  .c 在Linux  gcc编译后的文件后缀是 .o文件

### 引用的库头文件后缀  .h  会和源文件编译后的文件 一起通过链接器（link.exe）进行链接生成可执行程序

### 编译的步骤是预处理/预编译、编译、汇编
预处理/预编译：完成了包含头文件、宏定义的替换、注释的删除等文本操作生成包含头文件的代码和源文件的代码
编译：完成了语法分析、词法分析、语义分析、符号汇总（符号汇总会将全局变量名和函数名等收集起来）最终生成汇编代码
汇编：汇编代码转换成的二进制指令，将编译步骤中的汇总的符号都收集起来分配内存空间存储形成符号表

### 链接时  没有函数体的函数定义会去链接它们的具体实现，即汇编生成的符号表中 存在没有函数体的函数名称和函数的具体实现 ，它们的函数名称相同就会在它们之间建立连接，然后在使用函数时会根据函数名找到该函数的具体实现

~~~C
// https://cplusplus.com/reference/ c语言库函数查看
#include<stdio.h> // 引入头文件stdio.h printf函数必须引入该文件
int main() {
    // 预处理符号
    printf("hello world!\n"); // \n 是输出换行
    printf("当前文件的绝对路径是：%s\n", __FILE__); // __FILE__ 表示当前文件的绝对路径
    printf("当前函数的名称是：%s\n", __FUNCTION__); // __FUNCTION__ 表示当前函数的名称
    printf("当前日期是：%s\n", __DATE__); // __DATE__ 表示当前日期
    printf("当前时间是：%s\n", __TIME__); // __TIME__ 表示当前时间
    printf("当前代码的行号是：%d\n", __LINE__); // __LINE__ 表示当前代码的行号
    
    // exit（）函数关闭了所有打开的文件并终止程序，exit()函数的参数会被传递给一些操作系统，通常的约定是正常终止的程序传递值0,非正常终止的程序传递非0值。不同的退出值可能用来标识导致程序的失败的不同原因
    // ANSIC标准要求使用值0或宏EXIT_SUCCESS来指示程序正常终止，使用宏EXIT_FAILURE指示程序非正常中止。(宏和exit() 原型 在stdlib.h头文件中都可以找到 EXIT_SUCCESS EXIT_FAILURE)
    
    // VS studio 是不支持ANSIC标准所以以下代码不能使用，而 gcc 编译器是支持ANSIC标准的
    // exit(EXIT_SUCCESS); EXIT_SUCCESS就是0，exit函数调用相当于提前终止程序 return 0
    // exit(EXIT_FAILURE); EXIT_FAILURE就是1，exit函数调用相当于提前终止程序 return 1
    
    // 注意需要定义宏#define __DEBUG__
    // 当然VS studio 不需要定义 但是使用的时 _DEBUG
    // 其实 #ifdef _DEBUG 中 _DEBUG是条件表达式 代表是真就执行下面的语句而不为真就执行#else后的语句
#ifdef _DEBUG
	// 在 Debug 模式下执行的代码
	printf("debug环境下会编译打印该语句\n");
#else
	// 在其他模式下执行的代码
#endif
 
    return 0; // 标准返回0代表程序正常返回，其他返回表示程序异常
}
~~~
---
 

### 程序是如何运行的
- 程序必须载入内存中。在有操作系统的环境中一般是由操作系统完成。在独立的环境中程序的载入必须由手工完成，也可能是通过可执行代码置入只读内存来完成
- 程序执行开始就调用main函数
- 开始执行程序代码，这个时候程序将使用一个运行时的堆栈，存储函数的局部变量和返回地址，程序同时可以使用静态内存存储一些全局的变量或是常量
- 终止程序：正常终止main函数或异常终止
 

### Linux下gcc编译
~~~shell
# 生成可执行程序，如果是源文件相当于进行了预编译、编译、汇编、链接，而汇编代码转换成的二进制文件则只进行了链接
gcc [源文件或者是汇编代码转换成的二进制文件]
# -D参数 添加变量参数 例如 -D SZ=100 在main函数中宏SZ变量的值就是100
# -o参数指定输出文件，输出的到文件
# -E参数预编译
# -S参数编译生成汇编文件
# -c参数编译生成二进制程序文件
# -I参数指定需要的头文件目录
# -L参数指定需要的库文件目录
# -l参数指定需要的库名称
# -g参数包含gdb调试信息进行调试
# -On n=? 参数表示优化代码，n等于0到3，数字越大则优化越多
# -Wall参数提示警告信息

# 预编译生成文件，注意生成的文件后缀名是 .i
gcc [源文件] -E -o test.i
# -E参数是预编译
# -o参数是将标准输出输出到文件中，也就是预编译后的文件

# 编译生成文件，注意生成同名但是文件后缀名是 .s 的文件，文件中存放的是汇编代码
gcc [源文件或者是源文件预编译后的文件] -S 

# 汇编生成文件，注意生成同名但是文件后缀名是 .o 的文件，文件中存放的是汇编代码转换成的二进制指令
gcc [汇编代码文件] -c 

# 链接会生成 .out 文件

# 查看可执行的二进制文件的大小
size [可执行的二进制文件]
# text    data     bss     dec     hex    filename
# 103207  4792     3360    111359  1b2ff  ls
# text是代码区，data是静态变量和全局变量初始化区，bss是未初始化数据区
# dec是10进制大小、hex是16进制大小、filename是文件名称
# 代码区存放的是cpu的机器指令，是共享的且只读的，即代码被加载到内存中可以被多次执行并且无法修改内存中的代码
# data区存放初始化的静态变量和初始化的全局变量与常量
# bss区存放的是未初始化的静态变量和未初始化的全局变量，这些变量在程序开始执行之前被内核初始化为0或者是null

~~~
 