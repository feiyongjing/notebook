### 常见指针
~~~C
#include<stdio.h>

int main() {

	int num = 10;  // int类型占用4个字节，向内存空间中申请了4个连续的字节
	// &是取地址操作符，&用于获取变量的指针（变量占用连续内存空间中第一个字节的内存地址）
	printf("变量存储的数据是：%d，变量的内存地址是（其实是变量的指针）：%p\n", num, &num);

	// 使用int*类型存放变量的内存地址，而存储了存储了内存地址的int*类型的变量就是指针变量
	// * 表示变量p是指针变量，注意如果批量声明需要每个指针变量前添加*，例如 int *a, *b, *c; 
	// int 表示指针变量p存储内存地址中存放的数据类型是int类型（也就是现在num的类型）
	// int* 或者是 char* 等等其他的指针变量类型都是存储的内存地址编号，
	// 所以它们的大小和内存地址编号有关，而32位机器（x86）和64位机器(x64)的内存地址编号分别是4字节和8字节
	// 如果读指针变量加整数，那么是相当与 整数乘指针变量类型字节 加内存地址指针变量存放的内存地址
	// 即如下 p+2 就是 &num + 2*4
	int* p = &num

	// *写在指针变量名之前是解引用操作符
	// *p表示根据指针变量p中存放的内存地址找到该内存地址存放的数据（这里是变量num在内存中存放的数据），
	// 而给*p赋值就是修改指针变量p中存放的内存地址所对应位置数据（这里是修改变量num在内存中存放的数据，所以变量num变为了20）
	// 注意函数通过传递指针变量参数在函数体中修改数据会影响原变量的数据
	*p = 20;
	printf("通过指针修改变量存储的数据：%d\n", num);
	
	// 注意如果传递数组给函数，在函数中使用sizeof() 计算的是指针大小（4或者是8字节）而不是真正的数组
	
	
	// 程序中不要出现野指针（未知的指针，不知道具体指向那个变量的内存空间）
	// 例子一：指针未初始化，
	int* n; // 指针变量未初始化时给的是一个随机值
	*n =10; // 对随机的内存访问并且修改值可能会导致不可知的情况发生
	// 避免方式是指针明确指定初始化，如果不知道初始化什么可以初始化int* m= NULL
	// NULL的内存空间（NULL内存地址是0）数据不允许被修改
	int* m= NULL;
	if( m!= NULL ){
	    *m = 10; // 缺点是使用时必须要判断空指针异常才能修改内存空间的数据
	}
	
	// 例子二：数组元素指针越界操作
	int arr[10]={0};
	int* a= &arr;
	// 由于i可以等于10 导致指针越界修改内存空间的数据了
	for(int i=0;i<=10;i++){
	    *a = i;
	    a++;
	}
	
	// 例子三：不要在函数中返回离开函数作用域就被回收的变量指针
	
	
	// 指针变量相减，注意只能是数组中两个元素的指针相减
	int arr1[10]={0};
	printf("数组元素指针相减得到数字的绝对值的是两个元素之间元素的个数，例如下标0的元素指针减去下标9的元素指针是：%d\n", &arr1[0] - &arr1[9] );
	
	// 多级指针
	int f = 10;
	int* pf = &f;    // 一级指针
	int** pff = &pf  // 二级指针
	*pff;            // 解引用获取上一级的数据，如果是多级指针就是上一级的指针
	**pff = 20;      // 可以直接多次解引用获取原始变量并修改变量
	
	
	// 被const修饰的变量无法直接修改值但是可以通过指针变量来修改值
	int b=10;
	// 指针修改const修饰的变量
	// int* pb= &b;
	// *pb=20; 
	// 声明指针变量添加限制，不让它修改
	
	// const在*前面时，*pb 无法修改 但是 pd可以修改，即可以修改地址指向其他地址，但是无法修改地址内部的值
	// const int* pb= &b;
	// int const* pb= &b;
	
	// const在*后面时，pb 无法修改 但是 *pd可以修改，即可以修改地址内部的数据，但是无法修改地址指向其他地址
	// int* const pb= &b;
	
	// const在*前后都有时，pb 和 *pd 都无法修改，即无法修改地址指向其他地址，也无法修改地址内部的数据
	// const int* const pb= &b;
	// int const* const pb= &b;
	
	
	return 0; // 标准返回0代表程序正常返回，其他返回表示程序异常
}
~~~
---


### 字符指针
~~~C
// 字符指针变量可以存放常量字符串的首地址（其实就是字符数组的首地址）
// 由于是常量字符串，无法通过指针修改内存地址中的字符串，
// 所以需要const 修饰*a表示地址中的数据无法修改，使其在编译时就报错，而不是在运行时报错
const char* a = "ejirfj"  

printf("打印字符串%s", a);  // 直接给字符串的首地址会打印字符串直到字符串的结束字符 '\0' 
~~~
---


### 数组指针
~~~C
int a[10] = {1,2,3};

int* pa = &a;         // 获取数组的指针变量，但是这样写在编译时会有警告

// 数组元素类型 (*数组指针变量)[数组长度] = &数组名
int (*paa)[10] = &a;  // 获取数组的指针变量，不会有编译警告，原数组的长度不能省略
printf("pa是%p\n",pa);
printf("paa是%p\n", paa);

// 指针数组的指针获取
char* b[10] = {0};
char* (*pb)[10] = &b;
~~~
---


### 函数指针
~~~C
int add(int a,int b){
    return a + b;
}

int sub(int a,int b){
    return a - b;
}


int main(){
    
    printf("add函数的地址是%p\n", &add);
    printf("和数组名一样通过函数可以通过函数名直接获取函数地址%p\n", add);
    
    // 函数的返回值 (*函数指针变量)(函数参数类型) = &函数名
    int (*padd)(int, int) = &add;
    
    // 通过函数指针解引用获取函数并调用函数
    int ret = (*padd)(2, 3);
    // 甚至可以将解引用符号省略
    int ret2 = padd(2, 3);
    printf("通过函数指针解引用获取函数并调用函数，返回结果是%d\n", ret2);
    
    
    // 函数指针数组，arr就是函数指针数组
    int (*arr1[2])(int, int)={add, sub};
    
    // 指向函数指针数组的指针, parr1就是指向函数指针数组的指针
    int (*(*parr1)[2])(int, int) = &arr1
    
    return 0;
}

~~~
---