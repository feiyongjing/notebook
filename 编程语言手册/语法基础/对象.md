## 对象整体结构

### Java对象在内存中的存储结构包含三部分：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。
- 对象头又包含标记字（Mark Word）、类指针和数组长度。
- 实例数据为对象中的非静态成员变量。
- 对齐填充是为了保证对象存储地址按照8字节对齐（64位JVM）或4字节对齐（32位JVM）而做的填充。


对于对象的堆内存结构，我们可以使用JOL（Java Object Layout）工具来查看。在接下来的讲解中，我们也会反复用到这个工具。它的使用非常简单。跟引入其他类库一样，我们可以通过Maven或Gradle将其引入自己的项目中，如下所示。
~~~xml
// Maven
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.16</version>
    <scope>provided</scope>
</dependency>
~~~
~~~
// Gradle
implementation 'org.openjdk.jol:jol-core:0.16'
~~~

在项目中，我们需要通过编程来查看某个对象的存储结构。如下示例代码所示。
~~~java
// MyObject.java
public class MyObject {
  private long b;
  private int a;
  private Integer e;

  private static final int s = 1;
  public void f() {}
  //...省略方法...
}

// Demo9_1.java
import org.openjdk.jol.info.ClassLayout;
public class Demo9_1 {
  public static void main(String[] args) {
    System.out.println(
        ClassLayout.parseInstance(new MyObject()).toPrintable()
    );
  }
}
~~~

通过上面的代码，我们将MyObject类的对象在堆内存中的存储结构，打印出来，对于打印结果，我们做个简单的介绍。
- OFFSET表示字段相对于对象首地址的偏移地址，单位是字节。
- SIZE表示字段的大小，单位是字节。
- TYPE表示字段的类型。
- VALUE为字段值。
- space losses是整个对象内部对齐填充的总字节数

## 对象头
对象头又分为三部分：标记字（Mark Word）、类指针和数组长度
- 标记字在32位JVM中占4字节长度，在64位JVM中占8字节长度。标记字存储对象在运行过程中的一些信息，比如GC分代年龄（age）、锁标志位（lock）、是否偏向锁（biased_lock）、线程ID（thread）、时间戳（epoch）、哈希值（hashcode）等。标记字应该是Java对象存储结构中最复杂的部分。标记字记录的大部分信息，都用于多线程和JVM垃圾回收。关于标记字的具体存储结构和作用，在多线程和JVM模块中详细讲解。
- 类信息存储在方法区。为了方便获取某个对象所对应的类信息，对象头中会存储一个类指针，指向方法区中的类信息，也就是对应类信息在方法区中的内存地址。不过，有一个小问题：这里为啥叫“类指针”，而不是“类引用”呢？毕竟，Java中并没有指针，存储内存地址的是引用。实际上，这里的指针是指C++指针，因为JVM是用C++语言实现的，对象的存储结构、类的存储结构都是由C++代码来定义的。
- JVM将数组作为一种特殊的对象来看待，其内存存储结构跟普通对象几乎一样。唯一的区别是，数组的对象头中多了数组长度这样一个字段。在32位JVM和64位JVM中，此字段均占4字节长度。从而也可以得知，在Java中，数组的最大长度为2^32-1。

## 实例数据
实例数据存储的是对象里的非静态成员变量，可以是基本类型，也可以是引用类型。因为静态成员变量属于类，而非对象，所以，静态成员变量并非存储在对象中。在64位JVM中，各个类型的字节长度如下所示。
~~~
类型	字节大小
double	8
long	8
float	4
int	    4
short	2
char	2
byte	1
boolean	1
引用	 8
~~~
在内存中，对象的每个属性的内存地址，必须是自身字节长度的倍数。比如，long型、int型、char型属性的内存地址必须分别是8、4、2的倍数，如果不是，需要补齐。这样的存储要求叫做“字节对齐”，补齐的方法叫做“字节填充”。除了属性需要对齐填充之外，对象整体也需要对齐填充。对象整体按照8字节对齐，不足8字节的，在对象末尾补足8字节。这样每个对象都从8的倍数的内存地址处开始存储。

### 实际上，对象中的属性并非按照定义的先后顺序来存储的。
在存在字节对齐和对齐填充的情况下，对象中的属性以不同的顺序来存储，会导致对象所占用的总内存大小有所不同，为了尽量减少内存占用，JVM按照如下规则来安排属性的存储顺序。以下规则是使用的8字节对齐，jvm参数-XX:ObjectAlignmentInBytes可以设置对齐字节数，取值范围为[8, 256]，并且必须为2的幂次方（2^n形式）
- 规则一：先存储父类的属性，再存储子类的属性。
- 规则二：类中的属性默认按照如下先后顺序来存储：double/long、float/int、short/char、byte/boolean、object reference。此顺序受JVM参数-XX:FieldsAllocationStyle影响，不过此参数在高版本JDK中被废弃，以上默认排序方式就是最优排序方式。
- 规则三：任何属性的存储开始地址都是在该类型字节长度边界上，不足的需要提取进行字节对齐和填充，比如，long类型的属性的存储开始地址必须要在8字节对齐边界上，如果是30，就补2字节从32开始。对象整体按照8字节对齐和填充。
- 规则四：父类的属性和子类的属性之间4字节对齐，不足4字节的补齐4字节。
- 规则五：在应用规则4之后，如果父类的属性和子类的属性之间仍有间隙（比如，子类第一个属性的长度为8个字节，父类结尾4字节对齐，父类的属性和子类的属性之间要填充4字节，才能8字节对齐），那么，我们将子类属性按照float/int、short/char、byte/boolean、object reference的顺序，依次拿来填充间隙，直到间隙填充满或无法继续填充为止。同理，如果在对象头和类的属性之间有间隙，我们同样应用此条规则进行填充。此规则受JVM参数-XX:CompactFields的影响，默认为true。如果我们将-XX:CompactFields参数设置为false，此条规则将不再使用。

关于以上规则，我们举例来解释一下。示例代码如下。
~~~java
public class A {
  private char a;
  private long b;
  private float c;
  //...省略方法...
}

public class B extends A {
  private boolean a;
  private char b;
  private long c;
  private String d = "abc";
  //...省略方法...
}

public class Demo9_1 {
  public static void main(String[] args) {
    System.out.println(
        ClassLayout.parseInstance(new B()).toPrintable());
  }
}
~~~
我们使用JOL将上述代码中B类的对象的内存结构打印出来，这里特别说明一下，因为JVM开启了指针压缩，所以，本应该占8字节的类指针和引用类型属性，现在只占4字节。关于指针压缩，稍后会详细讲解。

结合规则分析上述打印结果。
按照规则一，我们先存储父类A的属性，后存储子类B的属性。
按照规则二，父类A中属性的存储顺序为：b、c、a，但对象头和父类A的属性之间会有间隙，所以，附加应用规则五，将属性c提前来填充间隙。因此，父类A的属性的最终存储顺序为c、b、a。

根据规则四，因为父类A的属性和子类B的属性之间不满足4字节对齐，所以，中间填充了2字节。
根据规则二，父类B中的属性的存储顺序为：c、b、a、d，但这样会导致父类A的属性和子类B的属性之间就会有4字节间隙，因此，附加应用规则五，我们把属性b、a提前来填充间隙。不过，填充之后，在存储long类型的属性c之前，我们需要再填充1字节以达到8字节对齐的目的。因此，子类B的属性的最终存储顺序为b、a、c、d，注意a和c之间有1字节是填充的空字节
最后，因为整个对象需要8字节对齐，所以，在对象末尾填充4字节。于是，整个对象总共占用48个字节，其中包括7字节的填充，也就是Space losses 整个对象内部对齐填充的总字节数

## 压缩类指针和引用
在上述JOL打印的结果中，发现类指针和引用为4字节大小，而非8字节大小。这是因为JVM默认开启了类指针压缩（-XX:+UseCompressedClassPointers参数）和引用压缩（-XX:+UseCompressedOops参数）。当然，我们也可以通过设置JVM参数(-XX:-UseCompressedClassPointers和-XX:-UseCompressedOops），将类指针压缩和引用压缩关闭。注意，在JDK8中，类指针压缩开启的前提是引用压缩也已开启。

之所以开启类指针压缩和引用压缩，是因为在编程开发时，我们会频繁地使用引用类型和类指针（每个对象都有一个类指针）。在64位JVM中，引用类型和类指针占用8字节，如果将其压缩至4字节，这将大大节省存储空间。

### 类指针压缩和引用压缩如何把8字节的地址压缩为4字节的呢？

因为类指针的压缩方式跟引用的压缩方式相似，所以，我们拿引用压缩举例讲解。压缩之后的引用类型属性只占4字节，引用类型属性中存储的是对象的内存地址，4字节可以寻址的内存大小为2^32个字节（一个字节一个地址），42亿字节也就是大约4GB。如果设置的堆大小超过4GB，那么，有些对象的地址就无法在引用类型属性中存储了。

前面讲到对象是按照8字节进行字节对齐的，也就是说，对象的首地址是8的倍数，表示成二进制之后，后三位二进制位均为0。引用类型属性存储的是对象的首地址，既然后三位都为0，那也就没必要存储了。这样，32个二进制位可以存储长度为35个二进制位的地址（后三位不存）。因此，4字节的引用类型可以寻址的内存空间大小变成了2^35个字节，也就是32GB。当我们要读取引用类型属性所引用的对象时，先从引用类型属性中读取压缩之后的对象首地址，然后左移3位便可得到真正的对象首地址。

### 如果设置的堆大小超过32GB，即便JVM设置了开启引用压缩，引用压缩也不会生效，那么，怎么才能突破32GB这个堆大小限制呢？

之所以可以用4字节寻址32GB的内存空间，是因为对象按照8字节对齐。
如果我们让对象按照16字节对齐，那么，对象的内存地址末尾的4位二进制位都为0，这样我们就可以用32个二进制位存储长度为36个二进制位的地址。4字节引用类型能寻址的内存空间大小变成了2^36个字节，也就是64GB。
如果想继续扩大寻址范围，我们只需要使用JVM参数-XX:ObjectAlignmentInBytes调大对象的对齐长度即可。 参数-XX:ObjectAlignmentInBytes的取值范围为[8, 256]，并且必须为2的幂次方（2^n形式）。在支持引用压缩的前提下，最大可设置的堆大小的计算公式为如下所示。例如，当JVM设置对象按照32个字节对齐时，通过压缩引用技术，堆最大可以设置为 128GB。
~~~
4GB * ObjectAlignmentInBytes
~~~

在前面章节中，我们讲到，Java之所以在有Integer等包装类的情况下，仍然引入int等基本类型，其中一个重要原因就是节省内存。现在，我们就可以更加准确的分析一下，int相对于Integer到底节省了多少内存。一个int数据占据4字节内存，一个Integer对象，对象头占据8字节（Mark Word在64位JVM中是8字节）+4字节（类指针是8字节，但是开启类指针压缩之后是4字节）=12个字节，然后再加上仅有的int类型属性，总共占据16字节。对比来看，一个Integer对象所占内存大小，是int类型数据所占内存大小的4倍。如果项目中大量使用数值，那么使用基本类型变量来表示，就比包装类对象，节省大量内存空间了。


