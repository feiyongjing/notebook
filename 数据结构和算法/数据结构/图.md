# 图

### 图的几个概念
- 顶点和边：顶点表示节点，边用来连接节点
- 有向图和无向图：表示节点之间的关联关系
- 有权图：表示边上面有权重
- 度、入度、出度：度表示节点上有多少连接的边，入度表示指向节点的有向边数量，出度表示节点指向其他节点的有向边数量

### 图的两种存储方式
- 邻接矩阵：适用于数据访问比较高的情况，对于稀疏矩阵（边比较少）的情况下有大量空间浪费
- 邻接表：适用于稀疏矩阵（边比较少）的情况，访问两个节点是否存在边需要遍历链表比较慢

            无向无权图      无向有权图    有向无权图      有向有权图
邻接矩阵     boolean[][]    int[][]      boolean[][]    int[][]  
邻接表       统一使用一维数组，数组中的元素是LinkedList


### 图的常见操作
- 检查两个顶点之间是否有边
  - boolean[][]中的元素表示是否存在边
  - 例如arr[1][3]的元素是true，表示节点1有指向节点3的边，同样arr[3][1]的元素是false，表示节点3没有有指向节点1的边，无向边则是两个位置的元素都是true
- 检查两个顶点边的权重：int[][]中的元素就是权重，权重是0表示没有边
- 获取和某个顶点相连的所有顶点和所有的边

## 图的实现
### 有向无权图的邻接矩阵实现
~~~java
public class Graph{
    private int v;
    private boolean[][] matrix;

    public Graph(int v){
        this.v = v;
        this.matrix = new boolean[v][v]; // 默认数组中的元素是false
    }

    public addEdge(int s, int t){
        matrix[s][t] = true;
        // matrix[t][s] = true;  如果是无向图是需要两条边的
    }
}
~~~
---

### 有向无权图的邻接表实现
~~~java
public class Graph{
    private int v;
    private LinkedList<Integer> adj[];

    public Graph(int v){
        this.v = v;
        this.adj = new LinkedList[v]; 
        for(int i=0; i<v; i++){
            this.adj[i] = new LinkedList<Integer>();
        }
    }

    public addEdge(int s, int t){
        adj[s].add(t);
        // adj[t].add(s);  如果是无向图是需要两条边的
    }
}
~~~
---

## 图中的常见算法简介
- 遍历和搜索
  - BFS：Breadth First Search 即广度优先搜索
  - DFS：Depth First Search 即深度优先搜索
- 最短路径
  - Dijkstra：针对有权图的单源最短路径算法，并且要求没有负权边
  - Bellman-Ford：针对有权图的单源最短路径算法，允许存在负权边
  - Floyd：针对有权图的多源最短路径算法，允许存在负权边，但不允许存在负权环
  - A*算法：启发式搜索算法，求有权图次优最短路径
- 最小生成树
  - Prim算法
  - Kruskal算法
- 最大流、二分匹配
  - Ford-Fulkerson
  - Edmonds-Karp

### 广度优先遍历
- 使用一个队列记录需要遍历的元素，再额外使用另外一个数组记录已经遍历过的元素

