# 常见的排序算法
- 冒泡排序，时间复杂度是O(n^2)，空间复杂度是O(1)，排序效率不受原数据有序性影响，是稳定排序算法
- 插入排序，时间复杂度是O(n^2)，空间复杂度是O(1)，排序效率受到原数据有序性影响，不是稳定排序算法
- 选择排序，时间复杂度是O(n^2)，空间复杂度是O(1)，排序效率受到原数据有序性影响，不是稳定排序算法
- 归并排序，时间复杂度是O(nlogn)，空间复杂度是O(n)，排序效率不受原数据有序性影响，是稳定排序算法
- 快速排序，时间复杂度是O(nlogn)
- 桶排序，时间复杂度是
- 计数排序
- 基数排序

## 冒泡排序
~~~java
public class BubbleSort{
    public static int[] sort(int[] arr){
        int l = arr.length-1;
        if(l<=0) return arr;
        for(int i=0; i<l; i++){
            boolean flag = false;
            for(int j=0; j<l-i ;j++){
                if( arr[j] > arr[j+1]){
                    int p = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = p;
                    flag = true;
                }
            }
            if(!flag) break;
        }
        return arr;
    }

    public static void main(String[] args){
        int[] res = sort(new int[]{1, 6, 2, 5, -2, 9, 8, -2, 7, 4, 3});
        System.out.println(Arrays.toString(res));
    }
}
~~~

## 插入排序
- 维持有序区间，每次在无须区间中获取一个值，移动到有序区间中找到应该存放的位置
~~~java
public class InsertSort{
    public static int[] sort(int[] arr){
        int l = arr.length-1;
        for(int i=0; i<l; i++){
            for(int j=i+1; j>=1; j--){
                if( arr[j] < arr[j-1] ){
                    int a = arr[j];
                    arr[j] = arr[j-1];
                    arr[j-1] = a;
                }else{
                    break;
                }
            }
        }
        return arr;
    }

    public static void main(String[] args){
        int[] res = sort(new int[]{1, 6, 2, 5, -2, 9, 8, -2, 7, 4, 3});
        System.out.println(Arrays.toString(res));
    }
}
~~~
---

## 选择排序
- 维持有序区间，每次在无须区间中找出最小值放入有序区间末尾(从小到大排序是末尾，从大到小排序是开头)
~~~java
public class SelectSort{
    public static int[] sort(int[] arr){
        int l = arr.length;
        if(l<=1) return arr;

        for(int i=0; i<l-1; i++){
            int minIndex = i;
            for(int j=i+1; j<l ;j++){
                if( arr[j] < arr[minIndex] ){
                    minIndex = j;
                }
            }

            int p = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = p;
        }
        return arr;
    }

    public static void main(String[] args){
        int[] res = sort(new int[]{1, 6, 2, 5, -2, 9, 8, -2, 7, 4, 3});
        System.out.println(Arrays.toString(res));
    }
}
~~~
---

## 归并排序
- 将数据分为两部分，对每部分的数据都进行排序，然后将两部分的有序数据进行合并

### 递归实现归并排序
~~~java
public class MergeSort{
    public static int[] sort(int[] arr){
        return mergeSort(arr, 0, arr.length-1);
    }

    private static int[] mergeSort(int[] arr, int left, int right){
        if(left == right) return new int[]{ arr[left] };

        int middle = (right-left)/2 + left;

        int[] leftArr = mergeSort(arr, left, middle);
        int[] rightArr = mergeSort(arr, middle+1, right);

        int[] res = new int[leftArr.length + rightArr.length];
        int p = 0;
        int p1 = 0;
        int p2 = 0;
        while(p1 < leftArr.length && p2 < rightArr.length){
            if(leftArr[p1] <= rightArr[p2]){
                res[p++] = leftArr[p1++];
            }else{
                res[p++] = rightArr[p2++];
            }
        }

        while(p1 < leftArr.length){
            res[p++] = leftArr[p1++];
        }

        while(p2 < rightArr.length){
            res[p++] = rightArr[p2++];
        }

        return res;
    }

    public static void main(String[] args){
        int[] res = sort(new int[]{1, 6, 2, 5, -2, 9, 8, -2, 7, 4, 3});
        System.out.println(Arrays.toString(res));
    }
}
~~~
---

### 非递归实现归并排序
~~~java
public class MergeSort{
    public static int[] sort(int[] arr) {
        if (arr.length <= 1) return arr;

        int[] temp = new int[arr.length];

        // 步长，每次2倍步长范围段内的元素进行排序
        int n = 1;
        while (n < arr.length) {
            int p = 0;
            while (p < arr.length) {
                int left = p;
                int right = Math.min(p + 2 * n - 1, arr.length - 1);
                int mid = n + left;
                if (mid < arr.length) {
                    mergeSort(arr, left, mid, right, temp);
                }
                p = p + 2 * n;
            }
            n = 2 * n;
        }

        return arr;
    }

    private static void mergeSort(int[] arr, int left, int mid, int right, int[] temp) {
        int p = left;
        int p1 = left;
        int p2 = mid;
        while (p1 < mid && p2 <= right) {
            if (arr[p1] <= arr[p2]) {
                temp[p++] = arr[p1++];
            } else {
                temp[p++] = arr[p2++];
            }
        }

        while (p1 < mid) {
            temp[p++] = arr[p1++];
        }

        while (p2 <= right) {
            temp[p++] = arr[p2++];
        }

        for (p = left; p <= right; p++) {
            arr[p] = temp[p];
        }
    }

    public static void main(String[] args) {
        int[] res = sort(new int[]{1, 9, -6, 2, 52, 10, 8, 2, 90, 20, 7, -2, 9, -8, -70, 82 - 2, 7, 4, -3});
        System.out.println(Arrays.toString(res));
    }
}
~~~
---



